//! Includes

#ifndef _orxCONTAINER_H_
#define _orxCONTAINER_H_

#include "orx.h"


//! Prototypes

void                                        orxContainer_Init();
void                                        orxContainer_Exit();
orxSTATUS                                   orxContainer_Set(orxOBJECT* _pstObject);

/** Misc defines
 */
#define orxCONTAINER_KU32_BANK_SIZE                     2048
#define orxCONTAINER_KU32_TEXT_BUFFER_SIZE              1024
#define orxCONTAINER_KST_DEFAULT_COLOR                  orx2RGBA(255, 0, 0, 255)

/** Config defines
 */
#define orxCONTAINER_KZ_CONFIG_SECTION                  "Containers"
#define orxCONTAINER_KZ_CONFIG_RUNTIME                  "ContainersRuntime"

#define orxCONTAINER_KZ_CONFIG_SHOW_DEBUG               "ShowDebug"
#define orxCONTAINER_KZ_CONFIG_CONTAINER_NAME           "Container"


 /** Static structure
  */
typedef struct __orxCONTAINER_STATIC_t
{
  orxBANK* pstContainerBank;               /**< Container bank */

} orxCONTAINER_STATIC
;
/***************************************************************************
 * Static variables                                                        *
 ***************************************************************************/

 /** Static data
  */
static orxCONTAINER_STATIC sstObject;

//! Helpers

static const orxSTRING orxCONTAINER_PrintGUID(const orxOBJECT* _pstObject, const orxSTRING _zPrefix = orxNULL)
{
  static orxCHAR sacBuffer[orxCONTAINER_KU32_TEXT_BUFFER_SIZE];
  orxString_NPrint(sacBuffer, sizeof(sacBuffer), "%s%s0x%016llX",
    (_zPrefix != orxNULL) ? _zPrefix : orxSTRING_EMPTY,
    (_zPrefix != orxNULL) ? "##" : orxSTRING_EMPTY,
    orxStructure_GetGUID(orxSTRUCTURE(_pstObject)));

  // Done!
  return sacBuffer;
}

#ifdef orxCONTAINER_IMPL

static void orxContainer_CommandSet(orxU32 _u32ArgNumber, const orxCOMMAND_VAR* _astArgList, orxCOMMAND_VAR* _pstResult)
{
  orxOBJECT* pstObject;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if (pstObject != orxNULL)
  {
    // Register the object
    if (orxContainer_Set(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }
}

static void orxContainer_DrawContainerName(orxOBJECT* _pstObject, orxVIEWPORT* _pstViewport, orxVECTOR _vOrigin)
{
  const orxFONT* pstFont;

  /* Gets default font */
  pstFont = orxFont_Get(orxFONT_KZ_DEFAULT_FONT_NAME);

  /* Valid? */
  if (pstFont != orxNULL)
  {
    orxBITMAP* pstBitmap;
    orxDISPLAY_TRANSFORM  stTextTransform;
    orxCHAR               acBuffer[32];

    /* Gets its bitmap */
    pstBitmap = orxTexture_GetBitmap(orxFont_GetTexture(pstFont));

    /* Clears text transform */
    orxMemory_Zero(&stTextTransform, sizeof(orxDISPLAY_TRANSFORM));

    /* Valid? */
    if (_pstViewport != orxNULL)
    {
      //orxAABOX  stBox;
      orxFLOAT  fWidth, fHeight;

      /* Gets its box & size */
      orxViewport_GetRelativeSize(_pstViewport, &fWidth, &fHeight);

      /* Inits transform's scale */
      stTextTransform.fScaleX = (orx2F(2.0f) * fWidth);
      stTextTransform.fScaleY = (orx2F(2.0f) * fHeight);

      /* Inits transform's destination */
      stTextTransform.fDstX = _vOrigin.fX + orx2F(10.0f);
      stTextTransform.fDstY = _vOrigin.fY + orx2F(10.0f);

      /* Writes string */
      orxString_NPrint(acBuffer, sizeof(acBuffer), orxObject_GetName(_pstObject));

      /* Displays it */
      orxDisplay_TransformText(acBuffer, pstBitmap, orxFont_GetMap(pstFont), &stTextTransform, orxCONTAINER_KST_DEFAULT_COLOR, orxDISPLAY_SMOOTHING_OFF, orxDISPLAY_BLEND_MODE_ALPHA);
    }
  }

  /* Done! */
  return;
}

static void orxContainer_DrawBoundingBox(orxOBJECT* _pstObject)
{
  orxVECTOR vWorldPosition;
  orxOBOX stBoundingBox;
  orxObject_GetWorldPosition(_pstObject, &vWorldPosition);
  orxObject_GetBoundingBox(_pstObject, &stBoundingBox);

  orxVECTOR vOrigin;
  /* Gets origin */
  orxVector_Sub(&vOrigin, &(stBoundingBox.vPosition), &(stBoundingBox.vPivot));

  orxRGBA stColor = orx2RGBA(255, 0, 0, 255);

  orxVIEWPORT* pstViewport;

  /* For all viewports */
  for (pstViewport = orxVIEWPORT(orxStructure_GetFirst(orxSTRUCTURE_ID_VIEWPORT));
    pstViewport != orxNULL;
    pstViewport = orxVIEWPORT(orxStructure_GetNext(pstViewport)))
  {
    /* Is enabled and supports debug? */
    if ((orxViewport_IsEnabled(pstViewport) != orxFALSE)
      && (!orxStructure_GetFlags(pstViewport, orxVIEWPORT_KU32_FLAG_NO_DEBUG)))
    {
      orxCAMERA* pstCamera;

      /* Gets viewport camera */
      pstCamera = orxViewport_GetCamera(pstViewport);

      /* Valid? */
      if (pstCamera != orxNULL)
      {
        orxAABOX    stFrustum;
        orxVECTOR   vCameraPosition;
        orxFLOAT    fZ;
        orxS32      i;

        /* Gets camera position */
        orxFrame_GetPosition(orxCamera_GetFrame(pstCamera), orxFRAME_SPACE_GLOBAL, &vCameraPosition);

        /* Gets its frustum */
        orxCamera_GetFrustum(pstCamera, &stFrustum);

        /* Stores its Z */
        fZ = stFrustum.vTL.fZ + vCameraPosition.fZ;

        orxVECTOR v1, v2, v3, v4;

        /* Sets it */
        orxVector_Set(&v1, (vOrigin.fX), (vOrigin.fY), fZ);
        orxVector_Set(&v2, (vOrigin.fX + stBoundingBox.vX.fX), (vOrigin.fY + stBoundingBox.vX.fY), fZ);
        orxVector_Set(&v3, (vOrigin.fX + stBoundingBox.vX.fX + stBoundingBox.vY.fX), (vOrigin.fY + stBoundingBox.vX.fY + stBoundingBox.vY.fY), fZ);
        orxVector_Set(&v4, (vOrigin.fX + stBoundingBox.vY.fX), (vOrigin.fY + stBoundingBox.vY.fY), fZ);

        orxVECTOR avVertexList[] =
        {
          v1, v2, v3, v4
        };

        for (int i = 0; i < 4; i++) {
          /* Stores its screen position */
          orxRender_GetScreenPosition(&avVertexList[i], pstViewport, &(avVertexList[i]));
        }

        /* Draws polygon */
        orxDisplay_DrawPolygon(avVertexList, (orxS32)4, stColor, orxFALSE);

        /* Draws name */
        orxContainer_DrawContainerName(_pstObject, pstViewport, avVertexList[0]);
      }
    }
  }
}

static void orxContainer_Update(const orxCLOCK_INFO* _pstClockInfo, void* _pContext)
{
  // Done!
  return;
}

static orxSTATUS orxFASTCALL orxContainer_EventHandler(const orxEVENT *_pstEvent)
{
  orxSTATUS eResult = orxSTATUS_SUCCESS;

  /* Checks */
  orxASSERT(_pstEvent->eType == orxEVENT_TYPE_RENDER);

  /* End of rendering? */
  if(_pstEvent->eID == orxRENDER_EVENT_STOP)
  {
    /* Pushes config section */
    orxConfig_PushSection(orxCONTAINER_KZ_CONFIG_SECTION);

    /* Show debug? */
    if(orxConfig_GetBool(orxCONTAINER_KZ_CONFIG_SHOW_DEBUG) != orxFALSE)
    {
      // Inspect all registered objects
      orxConfig_PushSection(orxCONTAINER_KZ_CONFIG_RUNTIME);
      for (orxU32 u32KeyIndex = 0, u32KeyCount = orxConfig_GetKeyCount(); u32KeyIndex < u32KeyCount; u32KeyIndex++)
      {
        const orxSTRING zKey = orxConfig_GetKey(u32KeyIndex);
        orxU64 u64GUID = orxU64_UNDEFINED;
        if (orxString_ToU64(zKey, &u64GUID, orxNULL) != orxSTATUS_FAILURE)
        {
          orxOBJECT* pstObject = orxOBJECT(orxStructure_Get(u64GUID));
          if (pstObject != orxNULL)
          {
            orxContainer_DrawBoundingBox(pstObject);
          }
          else
          {
            orxConfig_ClearValue(zKey);
          }
        }
      }
      orxConfig_PopSection();
    }

    /* Pops config section */
    orxConfig_PopSection();
  }

  /* Done! */
  return eResult;
}

void orxContainer_Init()
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Register clock callback to render inspector windows on each frame
  eResult = orxClock_Register(orxClock_Get(orxCLOCK_KZ_CORE), orxContainer_Update, orxNULL, orxMODULE_ID_MAIN, orxCLOCK_PRIORITY_NORMAL);

  /* Success? */
  if (eResult != orxSTATUS_FAILURE)
  {
    /* Creates banks */
    // sstObject.pstContainerBank = orxBank_Create(orxCONTAINER_KU32_BANK_SIZE, sizeof(orxOBJECT*), orxBANK_KU32_FLAG_NONE, orxMEMORY_TYPE_MAIN);
  }

  // Register commands
  orxCOMMAND_REGISTER_CORE_COMMAND(Container, Set, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, { "Object", orxCOMMAND_VAR_TYPE_U64 });

  /* Adds event handler */
  orxEvent_AddHandler(orxEVENT_TYPE_RENDER, orxContainer_EventHandler);
  orxEvent_SetHandlerIDFlags(orxContainer_EventHandler, orxEVENT_TYPE_RENDER, orxNULL, orxEVENT_GET_FLAG(orxRENDER_EVENT_STOP), orxEVENT_KU32_MASK_ID_ALL);

  // Done!
  return;
}

void orxContainer_Exit()
{
  // Unregister commands
  orxCOMMAND_UNREGISTER_CORE_COMMAND(Container, Set);

  // Unregister clock callback
  orxClock_Unregister(orxClock_Get(orxCLOCK_KZ_CORE), orxContainer_Update);

  // Clean runtime config section
  orxConfig_ClearSection(orxCONTAINER_KZ_CONFIG_RUNTIME);

  /* Deletes banks */
  // orxBank_Delete(sstObject.pstContainerBank);

  // Done!
  return;
}

orxSTATUS orxContainer_Set(orxOBJECT* _pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if (_pstObject != orxNULL)
  {
    orxConfig_PushSection(orxCONTAINER_KZ_CONFIG_RUNTIME);
    orxConfig_SetBool(orxCONTAINER_PrintGUID(_pstObject), orxTRUE);

    // Update status
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!
  return eResult;
}

#endif // orxCONTAINER_IMPL

#endif // _orxCONTAINER_H_