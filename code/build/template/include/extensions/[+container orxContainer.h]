//! Includes

#ifndef _orxCONTAINER_H_
#define _orxCONTAINER_H_

#include "orx.h"


//! Prototypes

void                                        orxContainer_Init();
void                                        orxContainer_Exit();
orxSTATUS                                   orxContainer_Set(orxOBJECT* _pstObject);

/** Misc defines
 */
#define orxCONTAINER_KU32_BANK_SIZE                2048
#define orxCONTAINER_KU32_TEXT_BUFFER_SIZE         1024

/** Config defines
 */
#define orxCONTAINER_KZ_CONFIG_SECTION                  "Containers"
#define orxCONTAINER_KZ_CONFIG_RUNTIME                  "ContainersRuntime"

#define orxCONTAINER_KZ_CONFIG_SHOW_DEBUG               "ShowDebug"
#define orxCONTAINER_KZ_CONFIG_CONTAINER_NAME           "Container"


 /** Static structure
  */
typedef struct __orxCONTAINER_STATIC_t
{
  orxBANK* pstContainerBank;               /**< Container bank */

} orxCONTAINER_STATIC
;
/***************************************************************************
 * Static variables                                                        *
 ***************************************************************************/

 /** Static data
  */
static orxCONTAINER_STATIC sstObject;

//! Helpers

static const orxSTRING orxCONTAINER_PrintGUID(const orxOBJECT* _pstObject, const orxSTRING _zPrefix = orxNULL)
{
  static orxCHAR sacBuffer[orxCONTAINER_KU32_TEXT_BUFFER_SIZE];
  orxString_NPrint(sacBuffer, sizeof(sacBuffer), "%s%s0x%016llX",
    (_zPrefix != orxNULL) ? _zPrefix : orxSTRING_EMPTY,
    (_zPrefix != orxNULL) ? "##" : orxSTRING_EMPTY,
    orxStructure_GetGUID(orxSTRUCTURE(_pstObject)));

  // Done!
  return sacBuffer;
}

#ifdef orxCONTAINER_IMPL

static void orxContainer_CommandSet(orxU32 _u32ArgNumber, const orxCOMMAND_VAR* _astArgList, orxCOMMAND_VAR* _pstResult)
{
  orxOBJECT* pstObject;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if (pstObject != orxNULL)
  {
    // Register the object
    if (orxContainer_Set(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }
}

static void orxContainer_ShowObject(orxOBJECT* _pstObject)
{
  orxVECTOR pos;
  orxOBOX obox;
  orxObject_GetWorldPosition(_pstObject, &pos);
  orxObject_GetBoundingBox(_pstObject, &obox);

  orxVIEWPORT* ptsMainCamera = orxViewport_Get("MainViewport");
  orxRender_GetScreenPosition(&pos, ptsMainCamera, &pos);
  obox.vPosition = pos;

  orxRGBA red = {255, 0, 0, 255};
  orxDisplay_DrawOBox(&obox, red, orxFALSE);
}

static void orxContainer_Update(const orxCLOCK_INFO* _pstClockInfo, void* _pContext)
{
  // Done!
  return;
}

static orxSTATUS orxFASTCALL orxContainer_EventHandler(const orxEVENT *_pstEvent)
{
  orxSTATUS eResult = orxSTATUS_SUCCESS;

  /* Checks */
  orxASSERT(_pstEvent->eType == orxEVENT_TYPE_RENDER);

  /* End of rendering? */
  if(_pstEvent->eID == orxRENDER_EVENT_STOP)
  {
    /* Pushes config section */
    orxConfig_PushSection(orxCONTAINER_KZ_CONFIG_SECTION);

    /* Show debug? */
    if(orxConfig_GetBool(orxCONTAINER_KZ_CONFIG_SHOW_DEBUG) != orxFALSE)
    {
      // Inspect all registered objects
      orxConfig_PushSection(orxCONTAINER_KZ_CONFIG_RUNTIME);
      for (orxU32 u32KeyIndex = 0, u32KeyCount = orxConfig_GetKeyCount(); u32KeyIndex < u32KeyCount; u32KeyIndex++)
      {
        const orxSTRING zKey = orxConfig_GetKey(u32KeyIndex);
        orxU64 u64GUID = orxU64_UNDEFINED;
        if (orxString_ToU64(zKey, &u64GUID, orxNULL) != orxSTATUS_FAILURE)
        {
          orxOBJECT* pstObject = orxOBJECT(orxStructure_Get(u64GUID));
          if (pstObject != orxNULL)
          {
            orxContainer_ShowObject(pstObject);
          }
          else
          {
            orxConfig_ClearValue(zKey);
          }
        }
      }
      orxConfig_PopSection();
    }

    /* Pops config section */
    orxConfig_PopSection();
  }

  /* Done! */
  return eResult;
}

void orxContainer_Init()
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Register clock callback to render inspector windows on each frame
  eResult = orxClock_Register(orxClock_Get(orxCLOCK_KZ_CORE), orxContainer_Update, orxNULL, orxMODULE_ID_MAIN, orxCLOCK_PRIORITY_NORMAL);

  /* Success? */
  if (eResult != orxSTATUS_FAILURE)
  {
    /* Creates banks */
    // sstObject.pstContainerBank = orxBank_Create(orxCONTAINER_KU32_BANK_SIZE, sizeof(orxOBJECT*), orxBANK_KU32_FLAG_NONE, orxMEMORY_TYPE_MAIN);
  }

  // Register commands
  orxCOMMAND_REGISTER_CORE_COMMAND(Container, Set, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, { "Object", orxCOMMAND_VAR_TYPE_U64 });

  /* Adds event handler */
  orxEvent_AddHandler(orxEVENT_TYPE_RENDER, orxContainer_EventHandler);
  orxEvent_SetHandlerIDFlags(orxContainer_EventHandler, orxEVENT_TYPE_RENDER, orxNULL, orxEVENT_GET_FLAG(orxRENDER_EVENT_STOP), orxEVENT_KU32_MASK_ID_ALL);

  // Done!
  return;
}

void orxContainer_Exit()
{
  // Unregister commands
  orxCOMMAND_UNREGISTER_CORE_COMMAND(Container, Set);

  // Unregister clock callback
  orxClock_Unregister(orxClock_Get(orxCLOCK_KZ_CORE), orxContainer_Update);

  // Clean runtime config section
  orxConfig_ClearSection(orxCONTAINER_KZ_CONFIG_RUNTIME);

  /* Deletes banks */
  // orxBank_Delete(sstObject.pstContainerBank);

  // Done!
  return;
}

orxSTATUS orxContainer_Set(orxOBJECT* _pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if (_pstObject != orxNULL)
  {
    orxConfig_PushSection(orxCONTAINER_KZ_CONFIG_RUNTIME);
    orxConfig_SetBool(orxCONTAINER_PrintGUID(_pstObject), orxTRUE);

    // Update status
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!
  return eResult;
}

#endif // orxCONTAINER_IMPL

#endif // _orxCONTAINER_H_

