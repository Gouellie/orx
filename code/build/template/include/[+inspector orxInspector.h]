//! Includes

#ifndef _orxINSPECTOR_H_
#define _orxINSPECTOR_H_

#include "orxImGui.h"


//! Prototypes

void                                        orxInspector_Init();
void                                        orxInspector_Exit();
orxSTATUS                                   orxInspector_RegisterObject(const orxOBJECT *_pstObject);
orxSTATUS                                   orxInspector_UnregisterObject(const orxOBJECT *_pstObject);
orxBOOL                                     orxInspector_IsObjectRegistered(const orxOBJECT *_pstObject);


//! Defines

#define orxINSPECTOR_KZ_CONFIG_SECTION      "Inspector"
#define orxINSPECTOR_KZ_CONFIG_RUNTIME      "InspectorRuntime"

#define orxINSPECTOR_KZ_CONFIG_INPUT        "Input"
#define orxINSPECTOR_KZ_CONFIG_SHADER       "Shader"
#define orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS "InspectorFields"

#define orxINSPECTOR_KZ_INPUT_INSPECT       "Inspect"
#define orxINSPECTOR_KZ_PARAM_HIGHLIGHT     "highlight"

#define orxINSPECTOR_KU32_TABLE_FLAGS       (ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable | ImGuiTableFlags_SizingStretchProp)


#ifdef orxINSPECTOR_IMPL


//! Variables / Structures

typedef struct __orxINSPECTOR_t
{
  const orxSTRING zInputSet;
  const orxSTRING zShader;
  orxBOOL         bInit;

} orxINSPECTOR;

static orxINSPECTOR sstInspector;


//! Helpers

void orxInspector_PrintGUID(const orxOBJECT *_pstObject, orxCHAR *_acBuffer, orxU32 _u32Size)
{
  orxString_NPrint(_acBuffer, _u32Size, "0x%016llX", orxStructure_GetGUID(orxSTRUCTURE(_pstObject)));
}

orxVECTOR *orxInspector_GetHighlightColor(const orxOBJECT *_pstObject, orxVECTOR *_pvColor)
{
  orxCOLOR  stColor;
  orxU64    u64GUID;

  // Pick a color based on the object's GUID
  u64GUID = orxStructure_GetGUID(_pstObject);
  orxVector_Set(&(stColor.vHSL), (orxMath_Sin((orxFLOAT)(u64GUID & 0xFFFFFFFF)) + 1.0f) / 2.0f, orxFLOAT_1, orx2F(0.7f));
  stColor.fAlpha = orxFLOAT_1;
  orxColor_FromHSLToRGB(&stColor, &stColor);

  // Done!
  return orxVector_Copy(_pvColor, &(stColor.vRGB));
}


//! Code

//! TODO: COMPLIANCE
#include <array>
#include <vector>

//! TODO: COMPLIANCE
using buf_t = std::array<orxCHAR, 1024>;
buf_t GetCStringCopy(const orxSTRING src)
{
  buf_t buffer{};
  auto copyLength = orxMIN(orxString_GetLength(src), buffer.size());
  std::copy_n(src, copyLength, buffer.begin());
  return buffer;
}

//! TODO: COMPLIANCE
buf_t GetConfigStringCopy(const orxSTRING key)
{
  return GetCStringCopy(orxConfig_GetString(key));
}

//! TODO: COMPLIANCE
buf_t GetConfigStringCopy(const orxSTRING key, orxS32 index)
{
  return GetCStringCopy(orxConfig_GetListString(key, index));
}


//! TODO: COMPLIANCE
void ConfigValueTableRow(const orxSTRING key, bool editable = true, const orxSTRING section = orxSTRING_EMPTY)
{
  ImGui::TableNextRow();

  // Draw the section column
  if(section != orxSTRING_EMPTY)
  {
    ImGui::TableNextColumn();
    ImGui::Text("%s", section);
  }

  // Draw the key column
  ImGui::TableNextColumn();
  ImGui::Text("%s", key);

  // Draw the value column
  ImGui::TableNextColumn();
  if(editable)
  {
    ImGui::PushID(key);
    if(orxConfig_IsList(key))
    {
      const size_t elements = orxConfig_GetListCount(key);
      std::vector<buf_t> buffers{};
      bool listElementChanged = false;
      for(auto i = 0; i < elements; i++)
      {
        // Push a unique ID for each input
        ImGui::PushID(i);

        // Initialize buffer with the current content
        auto buffer = GetConfigStringCopy(key, i);

        // Input text widget
        ImGui::InputText("", buffer.data(), buffer.size());

        // Track if the widget has received edits and lost focus
        auto changed = ImGui::IsItemDeactivated();

        // Input and button on the same line
        ImGui::SameLine();

        // Button to remove this list entry
        auto removed = ImGui::Button("Remove");

        // If we're not removing this entry, add it to the buffers defining this list
        if(!removed)
        {
          buffers.push_back(buffer);
        }

        // Track if anything in the list has changed
        listElementChanged = listElementChanged || changed || removed;
        ImGui::PopID();
      }

      // Widget to add an element to the list
      auto addedElement = ImGui::Button("Add list element");
      if(addedElement)
      {
        // If we're adding an element then we're changing the list
        listElementChanged = true;

        // Add an empty string as a placeholder for the new element
        buffers.push_back({'\0'});
      }

      if(listElementChanged)
      {
        // If any elements in the list have changed, update the list in config
        std::vector<const orxSTRING> valuePtrs{};
        for(auto i = 0; i < buffers.size(); i++)
        {
          valuePtrs.push_back(buffers[i].data());
        }
        const orxCHAR **pp = valuePtrs.data();
        orxConfig_SetListString(key, pp, (orxU32)valuePtrs.size());
      }
    }
    else
    {
      auto buf = GetConfigStringCopy(key);
      if(ImGui::InputText("", buf.data(), buf.size()))
      {
        orxConfig_SetString(key, buf.data());
      }
    }
    ImGui::PopID();
  }
  else
  {
    if(orxConfig_IsList(key))
    {
      // Show all values from the list
      if(ImGui::BeginCombo("", orxConfig_GetListString(key, 0)))
      {
        for(int i = 1; i < orxConfig_GetListCount(key); i++)
        {
          ImGui::Text("%s", orxConfig_GetListString(key, i));
        }
        ImGui::EndCombo();
      }
    }
    else
    {
      // Show text representation of a single value
      ImGui::Text("%s", orxConfig_GetString(key));
    }
  }
}

void orxInspector_ShowObjectGUID(const orxOBJECT *_pstObject)
{
  orxCHAR acGUID[20];
  
  // Get object guid
  orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
  ImGui::TextUnformatted(acGUID);
  ImGui::SameLine();

  // Make the guid easy to copy to the clipboard for use in commands
  if(ImGui::Button("Copy"))
  {
    ImGui::SetClipboardText(acGUID);
  }
  
  // Done!
  return;
}

void orxInspector_ShowObjectHeader()
{
  // Table header initialization
  ImGui::TableSetupColumn("Name");
  ImGui::TableSetupColumn("GUID");
  ImGui::TableSetupColumn("Inspector");
  ImGui::TableHeadersRow();
  
  // Done!
  return;
}

void orxInspector_ShowObjectButton(const orxOBJECT *_pstObject)
{
  ImGui::TableNextColumn();
  ImGui::TextUnformatted(orxObject_GetName(_pstObject));
  ImGui::TableNextColumn();
  orxInspector_ShowObjectGUID(_pstObject);
  ImGui::TableNextColumn();
  if(ImGui::Button("Inspect"))
  {
    orxInspector_RegisterObject(_pstObject);
  }
  
  // Done!
  return;
}

void orxInspector_ShowParent(const orxOBJECT *_pstObject)
{
  orxOBJECT *pstParent = orxOBJECT(orxObject_GetParent(_pstObject));
  if(pstParent != orxNULL)
  {
    if(ImGui::CollapsingHeader("Parent"))
    {
      ImGui::PushID(pstParent);
      
      if(ImGui::BeginTable("Parent", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        orxInspector_ShowObjectHeader();
        orxInspector_ShowObjectButton(pstParent);
      }
      ImGui::EndTable();
      
      ImGui::PopID();
    }
  }
  
  // Done!
  return;
}

void orxInspector_ShowSiblings(const orxOBJECT *_pstObject)
{
  orxOBJECT *pstParent = orxOBJECT(orxObject_GetParent(_pstObject));
  if(pstParent != orxNULL)
  {
    orxOBJECT *pstFirstSibling = orxObject_GetChild(pstParent);
    if(pstFirstSibling == _pstObject)
    {
      pstFirstSibling = orxObject_GetSibling(pstFirstSibling);
    }
    if(pstFirstSibling != orxNULL)
    {
      if(ImGui::CollapsingHeader("Siblings"))
      {
        if(ImGui::BeginTable("Siblings", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
        {
          orxInspector_ShowObjectHeader();
          for(orxOBJECT *pstSibling = pstFirstSibling;
              pstSibling != orxNULL;
              pstSibling = orxObject_GetSibling(pstSibling))
          {
            if(pstSibling != _pstObject)
            {
              ImGui::PushID(pstSibling);
              orxInspector_ShowObjectButton(pstSibling);
              ImGui::PopID();
            }
          }
        }
        ImGui::EndTable();
      }
    }
  }
  
  // Done!
  return;
}

void orxInspector_ShowChildren(const orxOBJECT *_pstObject)
{
  orxOBJECT *pstChild = orxObject_GetChild(_pstObject);
  if(pstChild != orxNULL)
  {
    if(ImGui::CollapsingHeader("Children"))
    {
      if(ImGui::BeginTable("Children", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        orxInspector_ShowObjectHeader();
        for(; pstChild != orxNULL; pstChild = orxObject_GetSibling(pstChild))
        {
          ImGui::PushID(pstChild);
          orxInspector_ShowObjectButton(pstChild);
          ImGui::PopID();
        }
      }
      ImGui::EndTable();
    }
  }
  
  // Done!
  return;
}

void orxInspector_ShowStatus(const orxOBJECT *_pstObject)
{
  if(_pstObject != orxNULL)
  {
    if(ImGui::CollapsingHeader("Status"))
    {
      if(ImGui::BeginTable("Status", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        // GUID
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("GUID");
        ImGui::TableNextColumn();
        orxInspector_ShowObjectGUID(_pstObject);

        // Group
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Group");
        ImGui::TableNextColumn();
        ImGui::Text("%s", orxString_GetFromID(orxObject_GetGroupID(_pstObject)));

        // Life time
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Life time");
        ImGui::TableNextColumn();
        ImGui::Text("%0.1f", orxObject_GetLifeTime(_pstObject));

        // Active time
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Active time");
        ImGui::TableNextColumn();
        ImGui::Text("%0.1f", orxObject_GetActiveTime(_pstObject));

        // Current animation
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Animation");
        ImGui::TableNextColumn();
        ImGui::TextUnformatted(orxObject_GetCurrentAnim(_pstObject));

        // World position
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Position");
        ImGui::TableNextColumn();
        orxVECTOR position;
        orxObject_GetWorldPosition(_pstObject, &position);
        ImGui::Text("(%0.1f, %0.1f, %0.1f)", position.fX, position.fY, position.fZ);

        // Velocity
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Speed");
        ImGui::TableNextColumn();
        orxVECTOR speed;
        orxObject_GetSpeed(_pstObject, &speed);
        ImGui::Text("(%0.1f, %0.1f)", speed.fX, speed.fY);

        // Rotation
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Rotation");
        ImGui::TableNextColumn();
        ImGui::Text("%0.1f degrees", orxObject_GetRotation(_pstObject) * orxMATH_KF_RAD_TO_DEG);

        // Angular velocity
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Angular velocity");
        ImGui::TableNextColumn();
        ImGui::Text("%0.1f degrees/second", orxObject_GetAngularVelocity(_pstObject) * orxMATH_KF_RAD_TO_DEG);

        // Scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Scale");
        ImGui::TableNextColumn();
        orxVECTOR scale;
        orxObject_GetScale(_pstObject, &scale);
        ImGui::Text("(%0.2f, %0.2f)", scale.fX, scale.fY);

        // Flip state of the object
        orxBOOL bFlipX, bFlipY;
        orxObject_GetFlip(_pstObject, &bFlipX, &bFlipY);

        // Show information on scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Flip");
        ImGui::TableNextColumn();
        ImGui::Text("(%s, %s)", (bFlipX ? "Flip X" : "Normal X"), (bFlipY ? "Flip Y" : "Normal Y"));
      }
      ImGui::EndTable();
    }
  }
  
  // Done!
  return;
}

void orxInspector_ShowConfig(const orxSTRING _zSection)
{
  if(ImGui::CollapsingHeader("Config"))
  {
    float fInitialIndent = 5.0f;
    ImGui::Indent(fInitialIndent);

    // Track additional indentation levels from parent config sections
    float fIndentOffset = 2.0f;

    // Object config section and its inheritance hierarchy
    if(ImGui::CollapsingHeader(_zSection))
    {
      // Push the selected config section to make it active
      orxConfig_PushSection(_zSection);

      // Create a table with one row per key/value pair in the section
      if(ImGui::BeginTable(_zSection, 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        // Section config
        ImGui::PushID(_zSection);
        for(orxU32 i = 0, iCount = orxConfig_GetKeyCount(); i < iCount; i++)
        {
          ConfigValueTableRow(orxConfig_GetKey(i), true);
        }
        ImGui::PopID();

        ImGui::EndTable();
      }

      orxConfig_PopSection();

      for(const orxSTRING zParent = orxConfig_GetParent(_zSection);
          (zParent != orxNULL) && (zParent != orxSTRING_EMPTY) && ImGui::CollapsingHeader(zParent, ImGuiTreeNodeFlags_DefaultOpen) && ImGui::BeginTable(zParent, 2, orxINSPECTOR_KU32_TABLE_FLAGS);
          zParent = orxConfig_GetParent(zParent))
      {
        ImGui::Indent(5.0f);
        fIndentOffset += 5.0f;

        // Show the config from the parent section too
        ImGui::PushID(zParent);
        orxConfig_PushSection(zParent);
        for(orxU32 i = 0, iCount = orxConfig_GetKeyCount(); i < iCount; i++)
        {
          ConfigValueTableRow(orxConfig_GetKey(i), true);
        }
        orxConfig_PopSection();
        ImGui::PopID();

        ImGui::EndTable();
      }
    }

    // Reset indentation from config sections if any was added
    if(fIndentOffset > 0.0f)
    {
      ImGui::Indent(-fIndentOffset);
    }

    // Other custom config values to show
    orxConfig_PushSection(_zSection);
    orxU32 u32ElementCount = orxConfig_GetListCount(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS);
    if((u32ElementCount > 0)
    && ImGui::CollapsingHeader("Custom Fields")
    && ImGui::BeginTable("Custom Fields", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      ImGui::PushID("Custom");

      ImGui::TableSetupColumn("Section");
      ImGui::TableSetupColumn("Key");
      ImGui::TableSetupColumn("Value");
      ImGui::TableHeadersRow();

      for(orxU32 u32Element = 0;
          u32Element < u32ElementCount;
          u32Element++)
      {
        const orxSTRING zPath = orxConfig_GetListString(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS, u32Element);
        if(*zPath != orxCHAR_NULL)
        {
          orxS32 s32SeparatorIndex = orxString_SearchCharIndex(zPath, '.', 0);
          if(s32SeparatorIndex > 0)
          {
            orxCHAR acSection[1024];

            ImGui::PushID(u32Element);

            orxString_NPrint(acSection, sizeof(acSection), "%.*s", s32SeparatorIndex, zPath);
            orxConfig_PushSection(acSection);
            ConfigValueTableRow(zPath + s32SeparatorIndex + 1, true, acSection);
            orxConfig_PopSection();

            ImGui::PopID();
          }
        }
      }
      ImGui::PopID();

      ImGui::EndTable();
    }
    orxConfig_PopSection();

    ImGui::Indent(-fInitialIndent);
  }

  // Done!
  return;
}

void orxInspector_ShowHighlightCheckbox(orxOBJECT *_pstObject)
{
  // Has a working graphic?
  if(orxObject_GetWorkingGraphic(_pstObject) != orxNULL)
  {
    orxVECTOR vColor;
    orxInspector_GetHighlightColor(_pstObject, &vColor);
    ImVec4 vHighlight = {vColor.fR, vColor.fG, vColor.fB, 1.0f};
    ImGui::TextColored(vHighlight, "Highlight");
    ImGui::SameLine();

    orxSHADERPOINTER *pstShaderPointer = orxOBJECT_GET_STRUCTURE(_pstObject, SHADERPOINTER);
    orxU32 u32HighlightShaderIndex = orxU32_UNDEFINED;
    if(pstShaderPointer != orxNULL)
    {
      for(orxU32 i = 0; i < orxSHADERPOINTER_KU32_SHADER_NUMBER; i++)
      {
        const orxSHADER *pstShader = orxShaderPointer_GetShader(pstShaderPointer, i);
        if((pstShader != orxNULL) && (orxString_Compare(orxShader_GetName(pstShader), sstInspector.zShader) == 0))
        {
          u32HighlightShaderIndex = i;
          break;
        }
      }
    }

    bool bHighlight = (u32HighlightShaderIndex != orxU32_UNDEFINED) ? true : false;
    if(ImGui::Checkbox("##highlight", &bHighlight))
    {
      if(bHighlight != false)
      {
        if(u32HighlightShaderIndex == orxU32_UNDEFINED)
        {
          orxObject_AddShader(_pstObject, sstInspector.zShader);
        }
      }
      else
      {
        if(u32HighlightShaderIndex != orxU32_UNDEFINED)
        {
          orxObject_RemoveShader(_pstObject, sstInspector.zShader);
        }
      }
    }
  }
  
  // Done!
  return;
}

void orxInspacter_ShowShaders(const orxOBJECT *_pstObject)
{
  orxBOOL bTableInitialized = orxFALSE;

  orxSHADERPOINTER *pstShaderPointer = orxOBJECT_GET_STRUCTURE(_pstObject, SHADERPOINTER);
  if(pstShaderPointer != orxNULL)
  {
    for(orxU32 i = 0; i < orxSHADERPOINTER_KU32_SHADER_NUMBER; i++)
    {
      const orxSHADER *pstShader = orxShaderPointer_GetShader(pstShaderPointer, i);
      if((pstShader != orxNULL) && (orxString_Compare(orxShader_GetName(pstShader), sstInspector.zShader) != 0))
      {
        if(bTableInitialized == orxFALSE)
        {
          if((!ImGui::CollapsingHeader("Shaders"))
          || (bTableInitialized = orxTRUE, !ImGui::BeginTable("Shaders", 2, orxINSPECTOR_KU32_TABLE_FLAGS)))
          {
            break;
          }
        }

        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Name");
        ImGui::TableNextColumn();
        ImGui::TextUnformatted(orxShader_GetName(pstShader));
      }
    }
    if(bTableInitialized != orxFALSE)
    {
      ImGui::EndTable();
    }
  }
  
  // Done!
  return;
}

void orxInspector_ShowGraphic(const orxOBJECT *_pstObject)
{
  orxGRAPHIC     *pstGraphic  = orxObject_GetWorkingGraphic(_pstObject);
  orxTEXTURE     *pstTexture  = orxObject_GetWorkingTexture(_pstObject);
  const orxSTRING zText       = orxObject_GetTextString(_pstObject);
  if((pstGraphic != orxNULL)
  && ((pstTexture != orxNULL)
   || (zText != orxSTRING_EMPTY)))
  {
    if(ImGui::CollapsingHeader("Graphic"))
    {
      // Setup table columns
      if(ImGui::BeginTable("Graphic", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        // Show object graphic

        // Flip state of the graphic
        orxBOOL bFlipX, bFlipY;
        orxGraphic_GetFlip(pstGraphic, &bFlipX, &bFlipY);

        // Show information on scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Flip");
        ImGui::TableNextColumn();
        ImGui::Text("(%s, %s)", (bFlipX ? "Flip X" : "Normal X"), (bFlipY ? "Flip Y" : "Normal Y"));

        if(zText != orxSTRING_EMPTY)
        {
          // Show object text

          // Identify type of graphic
          ImGui::TableNextColumn();
          ImGui::TextUnformatted("Text");

          // Show graphic content
          ImGui::TableNextColumn();
          ImGui::TextUnformatted(zText);
        }
        else
        {

          // Scale of graphic
          orxVECTOR vScale;
          orxObject_GetScale(_pstObject, &vScale);

          // Identify type of graphic
          ImGui::TableNextColumn();
          ImGui::TextUnformatted("Texture");

          // Show graphic content
          ImGui::TableNextColumn();
          // Get overall texture dimensions
          orxFLOAT fTextureWidth, fTextureHeight;
          orxTexture_GetSize(pstTexture, &fTextureWidth, &fTextureHeight);

          // Get the origin and size of the active graphic
          orxVECTOR vOrigin, vSize;
          orxGraphic_GetOrigin(pstGraphic, &vOrigin);
          orxGraphic_GetSize(pstGraphic, &vSize);

          // Find the location of the graphic within the overall texture in normalized coordinates
          ImVec2 avUVs[2];
          // Top left of the texture region
          avUVs[0].x = vOrigin.fX / fTextureWidth;
          avUVs[0].y = vOrigin.fY / fTextureHeight;
          // Lower right of the texture region
          avUVs[1].x = (vOrigin.fX + vSize.fX) / fTextureWidth;
          avUVs[1].y = (vOrigin.fY + vSize.fY) / fTextureHeight;

          // Swap UV coordinates if the object is flipped
          if(bFlipX)
          {
            float fTemp = avUVs[0].x;
            avUVs[0].x  = avUVs[1].x;
            avUVs[1].x  = fTemp;
          }
          if(bFlipY)
          {
            float fTemp = avUVs[0].y;
            avUVs[0].y  = avUVs[1].y;
            avUVs[1].y  = fTemp;
          }

          // Get the texture and display the portion that matches the object's graphic
          ImTextureID textureID = (ImTextureID)orxTexture_GetBitmap(pstTexture);
          ImGui::Image(textureID, {vSize.fX * vScale.fX, vSize.fY * vScale.fY}, avUVs[0], avUVs[1]);
        }
      }
      ImGui::EndTable();
    }
  }
  
  // Done!
  return;
}

void orxInspector_ShowObject(orxOBJECT *_pstObject)
{
  bool bRegistered = true;
  const orxSTRING zName = orxObject_GetName(_pstObject);

  ImGui::PushID(_pstObject);
  if(ImGui::Begin(zName, &bRegistered))
  {
    orxInspector_ShowHighlightCheckbox(_pstObject);
    orxInspector_ShowStatus(_pstObject);
    orxInspector_ShowConfig(zName);
    orxInspector_ShowGraphic(_pstObject);
    orxInspacter_ShowShaders(_pstObject);
    orxInspector_ShowParent(_pstObject);
    orxInspector_ShowSiblings(_pstObject);
    orxInspector_ShowChildren(_pstObject);
  }
  ImGui::End();
  ImGui::PopID();

  if(bRegistered == false)
  {
    orxInspector_UnregisterObject(_pstObject);
    orxObject_RemoveShader(_pstObject, sstInspector.zShader);
  }

  // Done!
  return;
}

void orxInspector_CommandRegisterObject(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->u64Value = orxU64_UNDEFINED;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if(pstObject != orxNULL)
  {
    // Register the object
    if(orxInspector_RegisterObject(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }

  // Done!
  return;
}

void orxInspector_CommandUnregisterObject(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->u64Value = orxU64_UNDEFINED;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if(pstObject != orxNULL)
  {
    // Unregister the object
    if(orxInspector_UnregisterObject(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }

  // Done!
  return;
}

void orxInspector_CommandIsObjectRegistered(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->bValue = orxFALSE;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Update result
  _pstResult->bValue = orxInspector_IsObjectRegistered(pstObject);

  // Done!
  return;
}

orxSTATUS orxInspector_EventHandler(const orxEVENT *_pstEvent)
{
  orxSTATUS eResult = orxSTATUS_SUCCESS;

  // Get the event payload
  orxSHADER_EVENT_PAYLOAD *pstPayload = (orxSHADER_EVENT_PAYLOAD *)_pstEvent->pstPayload;

  // Inspector highlight?
  if((orxString_Compare(pstPayload->zShaderName, sstInspector.zShader) == 0)
  && (orxString_Compare(pstPayload->zParamName, orxINSPECTOR_KZ_PARAM_HIGHLIGHT) == 0))
  {
    // Set the highlight color for the shader
    orxInspector_GetHighlightColor(orxOBJECT(_pstEvent->hSender), &(pstPayload->vValue));
  }

  // Done!
  return eResult;
}

void orxInspector_Update(const orxCLOCK_INFO *_pstClockInfo, void *_pContext)
{
  // Push input set
  orxInput_PushSet(sstInspector.zInputSet);

  // Should inspect object?
  if(orxInput_HasBeenActivated(orxINSPECTOR_KZ_INPUT_INSPECT))
  {
    orxVECTOR vMousePosition;

    // Pick object
    orxRender_GetWorldPosition(orxMouse_GetPosition(&vMousePosition), orxNULL, &vMousePosition);
    orxOBJECT *pstObject = orxObject_Pick(&vMousePosition, orxSTRINGID_UNDEFINED);

    // Found?
    if(pstObject != orxNULL)
    {
      // Toggle its registration
      if(orxInspector_IsObjectRegistered(pstObject))
      {
        orxInspector_UnregisterObject(pstObject);
      }
      else
      {
        orxInspector_RegisterObject(pstObject);
      }
    }
  }

  // Pop input set
  orxInput_PopSet();

  // Inspect all registered objects
  orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
  for(orxU32 u32KeyIndex = 0, u32KeyCount = orxConfig_GetKeyCount(); u32KeyIndex < u32KeyCount; u32KeyIndex++)
  {
    const orxSTRING zKey  = orxConfig_GetKey(u32KeyIndex);
    orxU64 u64GUID        = orxU64_UNDEFINED;
    if(orxString_ToU64(zKey, &u64GUID, orxNULL) != orxSTATUS_FAILURE)
    {
      orxOBJECT *pstObject = orxOBJECT(orxStructure_Get(u64GUID));
      if(pstObject != orxNULL)
      {
        orxInspector_ShowObject(pstObject);
      }
      else
      {
        orxConfig_ClearValue(zKey);
      }
    }
  }
  orxConfig_PopSection();

  // Done!
  return;
}

void orxInspector_Init()
{
  // Not already initialized?
  if(sstInspector.bInit == orxFALSE)
  {
    // Push config section
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_SECTION);

    // Inits variables
    orxMemory_Zero(&(sstInspector), sizeof(orxINSPECTOR));
    sstInspector.zInputSet  = (orxConfig_HasValue(orxINSPECTOR_KZ_CONFIG_INPUT) != orxFALSE) ? orxConfig_GetString(orxINSPECTOR_KZ_CONFIG_INPUT) : orxINSPECTOR_KZ_CONFIG_SECTION;
    sstInspector.zShader    = (orxConfig_HasValue(orxINSPECTOR_KZ_CONFIG_SHADER) != orxFALSE) ? orxConfig_GetString(orxINSPECTOR_KZ_CONFIG_SHADER) : orxINSPECTOR_KZ_CONFIG_SECTION;

    // Register clock callback to render inspector windows on each frame
    orxClock_Register(orxClock_Get(orxCLOCK_KZ_CORE), orxInspector_Update, orxNULL, orxMODULE_ID_MAIN, orxCLOCK_PRIORITY_LOWER);

    // Add event handler
    orxEvent_AddHandler(orxEVENT_TYPE_SHADER, orxInspector_EventHandler);
    orxEvent_SetHandlerIDFlags(orxInspector_EventHandler,
                               orxEVENT_TYPE_SHADER,
                               orxNULL,
                               orxEVENT_GET_FLAG(orxSHADER_EVENT_SET_PARAM),
                               orxEVENT_KU32_MASK_ID_ALL);

    // Register commands
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, RegisterObject, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, UnregisterObject, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, IsObjectRegistered, "Registered?", orxCOMMAND_VAR_TYPE_BOOL, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});

    // Enable input set
    orxInput_EnableSet(sstInspector.zInputSet, orxTRUE);

    // Update status
    sstInspector.bInit = orxTRUE;

    // Pop config section
    orxConfig_PopSection();
  }

  // Done!
  return;
}

void orxInspector_Exit()
{
  // Was initialized?
  if(sstInspector.bInit != orxFALSE)
  {
    // Disable input set
    orxInput_EnableSet(sstInspector.zInputSet, orxFALSE);
    orxInput_ClearSet(sstInspector.zInputSet);

    // Unregister commands
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, RegisterObject);
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, UnregisterObject);
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, IsObjectRegistered);

    // Remove event handler
    orxEvent_RemoveHandler(orxEVENT_TYPE_SHADER, orxInspector_EventHandler);

    // Unregister clock callback
    orxClock_Unregister(orxClock_Get(orxCLOCK_KZ_CORE), orxInspector_Update);

    // Clean runtime config section
    orxConfig_ClearSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);

    // Update status
    sstInspector.bInit = orxFALSE;
  }

  // Done!
  return;
}

orxSTATUS orxInspector_RegisterObject(const orxOBJECT *_pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    orxConfig_SetBool(acGUID, orxTRUE);
    orxConfig_PopSection();

    // Update status
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!
  return eResult;
}

orxSTATUS orxInspector_UnregisterObject(const orxOBJECT *_pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    orxConfig_ClearValue(acGUID);
    orxConfig_PopSection();

    // Update result
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!
  return eResult;
}

orxBOOL orxInspector_IsObjectRegistered(const orxOBJECT *_pstObject)
{
  orxBOOL bResult = orxFALSE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    bResult = orxConfig_GetBool(acGUID);
    orxConfig_PopSection();
  }

  // Done!
  return bResult;
}

#endif // orxINSPECTOR_IMPL

#endif // _orxINSPECTOR_H_
