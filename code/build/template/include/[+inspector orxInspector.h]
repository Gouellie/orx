//! Includes

#ifndef _orxINSPECTOR_H_
#define _orxINSPECTOR_H_

#include "orxImGui.h"


//! Prototypes

void                                        orxInspector_Init();
void                                        orxInspector_Exit();
orxSTATUS                                   orxInspector_RegisterObject(const orxOBJECT *_pstObject);
orxSTATUS                                   orxInspector_UnregisterObject(const orxOBJECT *_pstObject);


//! Defines

#define orxINSPECTOR_KZ_CONFIG_SECTION      "Inspector"
#define orxINSPECTOR_KZ_CONFIG_RUNTIME      "InspectorRuntime" 

#define orxINSPECTOR_KZ_CONFIG_INPUT        "Input"
#define orxINSPECTOR_KZ_CONFIG_SHADER       "Shader"
#define orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS "InspectorFields"

#define orxINSPECTOR_KZ_INPUT_INSPECT       "Inspect"
#define orxINSPECTOR_KZ_SHADER_HIGHLIGHT    "highlight"

#define orxINSPECTOR_KU32_TABLE_FLAGS       (ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable)


//! Variables / Structures

typedef struct __orxINSPECTOR_t
{
  const orxSTRING zInputSet;
  const orxSTRING zShader;
  orxBOOL         bInit;

} orxINSPECTOR;

static orxINSPECTOR sstInspector;


//! Helpers

void orxInspector_PrintGUID(const orxOBJECT *_pstObject, orxCHAR *_acBuffer, orxU32 _u32Size)
{
  orxString_NPrint(_acBuffer, _u32Size, "0x%016llX", orxStructure_GetGUID(orxSTRUCTURE(_pstObject)));
}

orxVECTOR *orxInspector_GetHighlightColor(const orxOBJECT *_pstObject, orxVECTOR *_pvColor)
{
  orxCOLOR  stColor;
  orxU64    u64GUID;
  
  // Pick a color based on the object's GUID
  u64GUID = orxStructure_GetGUID(_pstObject);
  orxVector_Set(&(stColor.vHSL), (orxMath_Sin((orxFLOAT)(u64GUID & 0xFFFFFFFF)) + 1.0f) / 2.0f, orxFLOAT_1, orx2F(0.7f));
  stColor.fAlpha = orxFLOAT_1;
  orxColor_FromHSLToRGB(&stColor, &stColor);

  // Done!
  return orxVector_Copy(_pvColor, &(stColor.vRGB));
}


//! Code

#ifdef orxINSPECTOR_IMPL

#include <inttypes.h>
#include <array>
#include <set>
#include <string>
#include <vector>

using buf_t = std::array<orxCHAR, 1024>;
buf_t GetCStringCopy(const orxSTRING src)
{
  buf_t buffer{};
  auto copyLength = orxMIN(orxString_GetLength(src), buffer.size());
  std::copy_n(src, copyLength, buffer.begin());
  return buffer;
}

buf_t GetConfigStringCopy(const orxSTRING key)
{
  return GetCStringCopy(orxConfig_GetString(key));
}

buf_t GetConfigStringCopy(const orxSTRING key, orxS32 index)
{
  return GetCStringCopy(orxConfig_GetListString(key, index));
}

/// @brief Table row for a single config key and value
/// @param key Config key to display
/// @param editable The widget will be editable if the value is true, otherwise it will be static
/// @param section If a section name is provided, it will be included in the table row
void ConfigValueTableRow(const orxSTRING key, bool editable, const orxSTRING section = orxSTRING_EMPTY)
{
  ImGui::TableNextRow();

  // Draw the section column
  if(section != orxNULL && section != orxSTRING_EMPTY)
  {
    ImGui::TableNextColumn();
    ImGui::Text("%s", section);
  }

  // Draw the key column
  ImGui::TableNextColumn();
  ImGui::Text("%s", key);

  // Draw the value column
  ImGui::TableNextColumn();
  if(editable)
  {
    ImGui::PushID(key);
    if(orxConfig_IsList(key))
    {
      const size_t elements = orxConfig_GetListCount(key);
      std::vector<buf_t> buffers{};
      std::set<size_t> removedElements{};
      bool listElementChanged = false;
      for(auto i = 0; i < elements; i++)
      {
        // Push a unique ID for each input
        ImGui::PushID(i);

        // Initialize buffer with the current content
        auto buffer = GetConfigStringCopy(key, i);

        // Input text widget
        ImGui::InputText("", buffer.data(), buffer.size());

        // Track if the widget has received edits and lost focus
        auto changed = ImGui::IsItemDeactivated();

        // Input and button on the same line
        ImGui::SameLine();

        // Button to remove this list entry
        auto removed = ImGui::Button("Remove");

        // If we're not removing this entry, add it to the buffers defining this list
        if(!removed)
        {
          buffers.push_back(buffer);
        }

        // Track if anything in the list has changed
        listElementChanged = listElementChanged || changed || removed;
        ImGui::PopID();
      }

      // Widget to add an element to the list
      auto addedElement = ImGui::Button("Add list element");
      if(addedElement)
      {
        // If we're adding an element then we're changing the list
        listElementChanged = true;

        // Add an empty string as a placeholder for the new element
        buffers.push_back({'\0'});
      }

      if(listElementChanged)
      {
        // If any elements in the list have changed, update the list in config
        std::vector<const orxSTRING> valuePtrs{};
        for(auto i = 0; i < buffers.size(); i++)
        {
          valuePtrs.push_back(buffers[i].data());
        }
        const orxCHAR **pp = valuePtrs.data();
        orxConfig_SetListString(key, pp, (orxU32)valuePtrs.size());
      }
    }
    else
    {
      auto buf = GetConfigStringCopy(key);
      if(ImGui::InputText("", buf.data(), buf.size()))
      {
        orxConfig_SetString(key, buf.data());
      }
    }
    ImGui::PopID();
  }
  else
  {
    if(orxConfig_IsList(key))
    {
      // Show all values from the list
      if(ImGui::BeginCombo("", orxConfig_GetListString(key, 0)))
      {
        for(int i = 1; i < orxConfig_GetListCount(key); i++)
        {
          ImGui::Text("%s", orxConfig_GetListString(key, i));
        }
        ImGui::EndCombo();
      }
    }
    else
    {
      // Show text representation of a single value
      ImGui::Text("%s", orxConfig_GetString(key));
    }
  }
}

/// @brief Show object GUID with a copy button
/// @param object GUID will be taken from this object
void ObjectGUIDWithCopy(const orxOBJECT *_pstObject)
{
  // Get object guid
  orxCHAR guid[20];
  orxInspector_PrintGUID(_pstObject, guid, sizeof(guid));
  ImGui::TextUnformatted(guid);
  ImGui::SameLine();
  // Make the guid easy to copy to the clipboard for use in commands
  if(ImGui::Button("Copy"))
  {
    ImGui::SetClipboardText(guid);
  }
}

/// @brief Setup header row for an object table
void ObjectTableHeadersRow()
{
  // Table header initialization
  ImGui::TableSetupColumn("Name");
  ImGui::TableSetupColumn("GUID");
  ImGui::TableSetupColumn("Inspector");
  ImGui::TableHeadersRow();
}

/// @brief Object table row, including inspector button
/// @param object Object to show in row
void ObjectButtonRow(const orxOBJECT *_pstObject)
{
  ImGui::TableNextColumn();
  ImGui::TextUnformatted(orxObject_GetName(_pstObject));
  ImGui::TableNextColumn();
  ObjectGUIDWithCopy(_pstObject);
  ImGui::TableNextColumn();
  if(ImGui::Button("Inspect"))
  {
    orxInspector_RegisterObject(_pstObject);
  }
}

/// @brief Parent object inspector. Only shows if object has a parent object.
/// @param object Object to retrieve parent from
void ParentObject(const orxOBJECT *_pstObject)
{
  auto parent = orxOBJECT(orxObject_GetParent(_pstObject));
  if(parent != orxNULL && ImGui::CollapsingHeader("Parent"))
  {
    ImGui::PushID(parent);
    if(ImGui::BeginTable("Parent", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      ObjectTableHeadersRow();
      ObjectButtonRow(parent);
    }
    ImGui::EndTable();
    ImGui::PopID();
  }
}

/// @brief Sibling objects inspector. Only shows if object has one or more sibling objects.
/// @param object Object to retrieve siblings from
void SiblingObjects(const orxOBJECT *_pstObject)
{
  auto parent = orxOBJECT(orxObject_GetParent(_pstObject));
  if(parent != orxNULL)
  {
    auto firstSibling = orxObject_GetChild(parent);
    if(firstSibling != orxNULL && ImGui::CollapsingHeader("Siblings"))
    {
      if(ImGui::BeginTable("Siblings", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        ObjectTableHeadersRow();
        for(orxOBJECT *sibling = firstSibling; sibling != orxNULL; sibling = orxObject_GetSibling(sibling))
        {
          if(sibling != _pstObject)
          {
            ImGui::PushID(sibling);
            ObjectButtonRow(sibling);
            ImGui::PopID();
          }
        }
      }
      ImGui::EndTable();
    }
  }
}

/// @brief Child objects inspector. Only shows if object has one or more child objects.
/// @param object Object to retrieve children from
void ChildObjects(const orxOBJECT *_pstObject)
{
  auto firstChild = orxObject_GetChild(_pstObject);
  if(firstChild != orxNULL && ImGui::CollapsingHeader("Children"))
  {
    if(ImGui::BeginTable("Children", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      ObjectTableHeadersRow();
      for(orxOBJECT *child = firstChild; child != orxNULL; child = orxObject_GetSibling(child))
      {
        ImGui::PushID(child);
        ObjectButtonRow(child);
        ImGui::PopID();
      }
    }
    ImGui::EndTable();
  }
}

/// @brief Object status inspector
/// @param object Object to retrieve status data from
void Status(const orxOBJECT *_pstObject)
{
  // Do nothing if the object is invalid/null
  if(!_pstObject)
  {
    return;
  }

  if(ImGui::CollapsingHeader("Status"))
  {
    if(ImGui::BeginTable("Status", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      // GUID
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("GUID");
      ImGui::TableNextColumn();
      ObjectGUIDWithCopy(_pstObject);

      // Life time
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Life time");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f", orxObject_GetLifeTime(_pstObject));

      // Active time
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Active time");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f", orxObject_GetActiveTime(_pstObject));

      // Group
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Group");
      ImGui::TableNextColumn();
      ImGui::Text("%s", orxString_GetFromID(orxObject_GetGroupID(_pstObject)));

      // Current animation
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Animation");
      ImGui::TableNextColumn();
      ImGui::TextUnformatted(orxObject_GetCurrentAnim(_pstObject));

      // World position
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Position");
      ImGui::TableNextColumn();
      orxVECTOR position;
      orxObject_GetWorldPosition(_pstObject, &position);
      ImGui::Text("(%0.1f, %0.1f, %0.1f)", position.fX, position.fY, position.fZ);

      // Velocity
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Speed");
      ImGui::TableNextColumn();
      orxVECTOR speed;
      orxObject_GetSpeed(_pstObject, &speed);
      ImGui::Text("(%0.1f, %0.1f)", speed.fX, speed.fY);

      // Rotation
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Rotation");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f degrees", orxObject_GetRotation(_pstObject) * orxMATH_KF_RAD_TO_DEG);

      // Angular velocity
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Angular velocity");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f degrees/second", orxObject_GetAngularVelocity(_pstObject) * orxMATH_KF_RAD_TO_DEG);

      // Scale
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Scale");
      ImGui::TableNextColumn();
      orxVECTOR scale;
      orxObject_GetScale(_pstObject, &scale);
      ImGui::Text("(%0.1f, %0.1f)", scale.fX, scale.fY);
    }
    ImGui::EndTable();
  }
}

/// @brief Object configuration inspector
/// @param section Configuration section to render, including inherited sections
/// @param editable Configuration is editable if orxTRUE. Configuration is static if orxFALSE.
void Config(const orxSTRING section, bool editable)
{
  if(ImGui::CollapsingHeader("Config"))
  {
    const auto initialIndent = 5.0f;
    ImGui::Indent(initialIndent);

    auto ConfigRows = [editable]()
    {
      auto keys = orxConfig_GetKeyCount();
      for(orxU32 i = 0; i < keys; i++)
      {
        auto key = orxConfig_GetKey(i);
        ConfigValueTableRow(key, editable);
      }
    };

    // Track additional indentation levels from parent config sections
    auto indentOffset = 2.0f;

    // Object config section and its inheritance hierarchy
    if(ImGui::CollapsingHeader(section))
    {
      // Push the selected config section to make it active
      orxConfig_PushSection(section);

      // Create a table with one row per key/value pair in the section
      if(ImGui::BeginTable(section, 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        // Section config
        ImGui::PushID(section);
        ConfigRows();
        ImGui::PopID();

        ImGui::EndTable();
      }

      orxConfig_PopSection();

      auto parent = orxConfig_GetParent(section);
      auto tableFlags = ImGuiTreeNodeFlags_DefaultOpen;
      while(parent != orxNULL && parent != orxSTRING_EMPTY && ImGui::CollapsingHeader(parent, tableFlags) && ImGui::BeginTable(parent, 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        ImGui::Indent(5.0f);
        indentOffset += 5.0f;
        // Show the config from the parent section too
        ImGui::PushID(parent);
        orxConfig_PushSection(parent);
        ConfigRows();
        orxConfig_PopSection();
        ImGui::PopID();
        parent = orxConfig_GetParent(parent);

        ImGui::EndTable();
      }
    }

    // Reset indentation from config sections if any was added
    if(indentOffset > 0.0f)
    {
      ImGui::Indent(-indentOffset);
    }

    // Other custom config values to show
    orxConfig_PushSection(section);
    if(orxConfig_HasValueNoCheck(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS) &&
        ImGui::CollapsingHeader("Custom fields") &&
        ImGui::BeginTable("Custom fields", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      ImGui::PushID("Custom");
      // Table header setup
      ImGui::TableSetupColumn("Section");
      ImGui::TableSetupColumn("Key");
      ImGui::TableSetupColumn("Value");
      ImGui::TableHeadersRow();
      auto elements = orxConfig_GetListCount(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS);
      for(int element = 0; element < elements; element++)
      {
        auto path = std::string(orxConfig_GetListString(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS, element));
        if(path.length() == 0)
        {
          // Empty string, nothing to do
          continue;
        }

        ImGui::PushID(element);
        // Section is the substring from the start until before the first '.'
        auto section = path.substr(0, path.find('.'));
        // Key is the part after the first '.' until the end
        auto key = path.substr(path.find('.') + 1, path.length());
        orxConfig_PushSection(section.data());
        ConfigValueTableRow(key.data(), editable, section.data());
        orxConfig_PopSection();
        ImGui::PopID();
      }
      ImGui::PopID();

      ImGui::EndTable();
    }
    orxConfig_PopSection();

    ImGui::Indent(-initialIndent);
  }
}

/// @brief Information on the shaders applied to an object
struct ObjectShaderSpec
{
  int shaderCount{0};             // Number of shaders applied to an object
  bool hasHighlightShader{false}; // True if the inspector highlight shader is applied, otherwise false
};

/// @brief Get information on the shaders applied to an object
/// @param object Object to check
/// @return Shader information for the object
ObjectShaderSpec GetObjectShaderSpec(const orxOBJECT *_pstObject)
{
  ObjectShaderSpec spec{};

  // Get a reference to the highlighting shader
  auto shader = orxShader_CreateFromConfig(sstInspector.zShader);
  orxASSERT(shader != orxNULL);
  // Get the shader's ID
  auto highlightShaderID = orxShader_GetID(shader);
  // Clean up our shader reference
  orxShader_Delete(shader);

  auto shaderPointer = orxOBJECT_GET_STRUCTURE(_pstObject, SHADERPOINTER);
  if(shaderPointer != orxNULL)
  {
    for(int i = 0; i < orxSHADERPOINTER_KU32_SHADER_NUMBER; i++)
    {
      auto objectShader = orxShaderPointer_GetShader(shaderPointer, i);
      if(objectShader != orxNULL)
      {
        spec.shaderCount++;
        auto objectShaderID = orxShader_GetID(objectShader);
        if(objectShaderID == highlightShaderID)
        {
          spec.hasHighlightShader = true;
        }
      }
    }
  }

  return spec;
}

/// @brief Show a checkbox to enable/disable a shader on an object to highlight it visually
/// @param object Object to apply/remove shader from in response to the checkbox state
void HighlightShaderCheckbox(orxOBJECT *_pstObject)
{
  if(orxObject_GetWorkingGraphic(_pstObject) != orxNULL)
  {
    auto shaderSpec = GetObjectShaderSpec(_pstObject);

    orxVECTOR highlightColor;
    orxInspector_GetHighlightColor(_pstObject, &highlightColor);
    ImVec4 highlightColorIm = {highlightColor.fR, highlightColor.fG, highlightColor.fB, 1.0};
    ImGui::TextColored(highlightColorIm, "Highlight with shader");
    ImGui::SameLine();

    // The highlight is active if we have a non-NULL pointer to the highlight shader
    bool highlight = shaderSpec.hasHighlightShader;
    if(ImGui::Checkbox("##highlight", &highlight))
    {
      if(highlight && !shaderSpec.hasHighlightShader)
      {
        // No existing shaders, so we can add the highlight directly to the object
        orxObject_AddShader(_pstObject, sstInspector.zShader);
      }
      else if(!highlight && shaderSpec.hasHighlightShader)
      {
        // We have the shader set, so remove it
        orxObject_RemoveShader(_pstObject, sstInspector.zShader);
      }
    }
  }
}

/// @brief Object active shader inspector
/// @param object Object to retrieve shader information from
void Shaders(const orxOBJECT *_pstObject)
{
  auto shaderSpec = GetObjectShaderSpec(_pstObject);

  if(shaderSpec.shaderCount > 0 && ImGui::CollapsingHeader("Shaders"))
  {
    if(ImGui::BeginTable("Shaders", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      auto shaderPointer = orxOBJECT_GET_STRUCTURE(_pstObject, SHADERPOINTER);
      orxASSERT(shaderPointer != orxNULL);
      for(int i = 0; i < orxSHADERPOINTER_KU32_SHADER_NUMBER; i++)
      {
        auto shader = orxShaderPointer_GetShader(shaderPointer, i);
        if(shader != orxNULL)
        {
          ImGui::TableNextColumn();
          ImGui::TextUnformatted("Name");
          ImGui::TableNextColumn();
          ImGui::TextUnformatted(orxShader_GetName(shader));
        }
      }
    }
    ImGui::EndTable();
  }
}

/// @brief Object graphic inspector, showing currently active graphic for an object. Only shows if the object has a graphic or animation.
/// @param object Object to retrieve graphic information from
void Graphic(const orxOBJECT *_pstObject)
{
  auto graphic = orxObject_GetWorkingGraphic(_pstObject);
  auto texture = orxObject_GetWorkingTexture(_pstObject);
  auto text = orxObject_GetTextString(_pstObject);
  if((graphic != orxNULL && texture != orxNULL || text != orxSTRING_EMPTY) && ImGui::CollapsingHeader("Graphic"))
  {
    // Setup table columns
    if(ImGui::BeginTable("Graphic", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      if(text != orxSTRING_EMPTY)
      {
        // Show object text

        // Identify type of graphic
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Text");
        // Show graphic content
        ImGui::TableNextColumn();
        ImGui::TextUnformatted(text);
      }
      else
      {
        // Show object graphic

        // Scale of graphic
        orxVECTOR scale;
        orxObject_GetScale(_pstObject, &scale);

        // Show information on scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Scale");
        ImGui::TableNextColumn();
        ImGui::Text("(%0.1f, %0.1f)", scale.fX, scale.fY);

        // Flip state of the graphic
        orxBOOL flipX, flipY;
        orxObject_GetFlip(_pstObject, &flipX, &flipY);

        // Show information on scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Flip");
        ImGui::TableNextColumn();
        ImGui::Text("(%s, %s)", (flipX ? "Flip X" : "Normal X"), (flipY ? "Flip Y" : "Normal Y"));

        // Identify type of graphic
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Texture");

        // Show graphic content
        ImGui::TableNextColumn();
        // Get overall texture dimensions
        orxFLOAT textureWidth, textureHeight;
        orxTexture_GetSize(texture, &textureWidth, &textureHeight);

        // Get the origin and size of the active graphic
        orxVECTOR origin, size;
        orxGraphic_GetOrigin(graphic, &origin);
        orxGraphic_GetSize(graphic, &size);

        // Find the location of the graphic within the overall texture in normalized coordinates
        ImVec2 uv0, uv1;
        // Top left of the texture region
        uv0.x = origin.fX / textureWidth;
        uv0.y = origin.fY / textureHeight;
        // Lower right of the texture region
        uv1.x = (origin.fX + size.fX) / textureWidth;
        uv1.y = (origin.fY + size.fY) / textureHeight;

        // Flip uv coordinates if the object is flipped
        ImVec2 uv0Temp{uv0};
        if(flipX)
        {
          uv0.x = uv1.x;
          uv1.x = uv0Temp.x;
        }
        if(flipY)
        {
          uv0.y = uv1.y;
          uv1.y = uv0Temp.y;
        }

        // Get the texture and display the portion that matches the object's graphic
        auto textureID = (ImTextureID)orxTexture_GetBitmap(texture);
        ImGui::Image(textureID, {size.fX * scale.fX, size.fY * scale.fY}, uv0, uv1);
      }
    }
    ImGui::EndTable();
  }
}

/// @brief Object inspector window
/// @param object Object to inspect
void orxInspector_InspectObject(orxOBJECT *_pstObject)
{
  bool registered = true;
  auto name = orxObject_GetName(_pstObject);
  ImGui::PushID(_pstObject);
  if(ImGui::Begin(name, &registered))
  {
    HighlightShaderCheckbox(_pstObject);
    Status(_pstObject);
    Config(name, true);
    Graphic(_pstObject);
    Shaders(_pstObject);
    ParentObject(_pstObject);
    SiblingObjects(_pstObject);
    ChildObjects(_pstObject);
  }
  ImGui::End();
  ImGui::PopID();
  if(registered == false)
  {
    orxInspector_UnregisterObject(_pstObject);
    orxObject_RemoveShader(_pstObject, sstInspector.zShader);
  }
}

void orxInspector_CommandRegisterObject(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->u64Value = orxU64_UNDEFINED;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if(pstObject != orxNULL)
  {
    // Register the object
    if(orxInspector_RegisterObject(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }
}

void orxInspector_CommandUnregisterObject(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->u64Value = orxU64_UNDEFINED;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if(pstObject != orxNULL)
  {
    // Unregister the object
    if(orxInspector_UnregisterObject(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }
}

orxSTATUS orxInspector_EventHandler(const orxEVENT *_pstEvent)
{
  orxSTATUS eResult = orxSTATUS_SUCCESS;

  // Get the event payload
  orxSHADER_EVENT_PAYLOAD *pstPayload = (orxSHADER_EVENT_PAYLOAD *)_pstEvent->pstPayload;

  // Inspector highlight?
  if((orxString_Compare(pstPayload->zShaderName, sstInspector.zShader) == 0)
  && (orxString_Compare(pstPayload->zParamName, orxINSPECTOR_KZ_SHADER_HIGHLIGHT) == 0))
  {
    // Set the highlight color for the shader
    orxInspector_GetHighlightColor(orxOBJECT(_pstEvent->hSender), &(pstPayload->vValue));
  }

  // Done!
  return eResult;
}

void orxInspector_Update(const orxCLOCK_INFO *_pstClockInfo, void *_pContext)
{
  // Push input set
  orxInput_PushSet(sstInspector.zInputSet);

  // Should inspect object?
  if(orxInput_HasBeenActivated(orxINSPECTOR_KZ_INPUT_INSPECT))
  {
    orxVECTOR vMousePosition;
    
    // Pick object
    orxRender_GetWorldPosition(orxMouse_GetPosition(&vMousePosition), orxNULL, &vMousePosition);
    orxOBJECT *pstObject = orxObject_Pick(&vMousePosition, orxSTRINGID_UNDEFINED);
    
    // Found?
    if(pstObject != orxNULL)
    {
      // Register it
      orxInspector_RegisterObject(pstObject);
    }
  }

  // Pop input set
  orxInput_PopSet();

  // Inspect all registered objects
  orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
  for(orxU32 u32KeyIndex = 0, u32KeyCount = orxConfig_GetKeyCount(); u32KeyIndex < u32KeyCount; u32KeyIndex++)
  {
    const orxSTRING zKey  = orxConfig_GetKey(u32KeyIndex);
    orxU64 u64GUID        = orxU64_UNDEFINED;
    if(orxString_ToU64(zKey, &u64GUID, orxNULL) != orxSTATUS_FAILURE)
    {
      orxOBJECT *pstObject = orxOBJECT(orxStructure_Get(u64GUID));
      if(pstObject != orxNULL)
      {
        orxInspector_InspectObject(pstObject);
      }
      else
      {
        orxConfig_ClearValue(zKey);
      }
    }
  }
  orxConfig_PopSection();
  
  // Done!
  return;
}

void orxInspector_Init()
{
  // Not already initialized?
  if(sstInspector.bInit == orxFALSE)
  {
    // Push config section
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_SECTION);

    // Inits variables
    orxMemory_Zero(&(sstInspector), sizeof(orxINSPECTOR));
    sstInspector.zInputSet  = orxConfig_GetString(orxINSPECTOR_KZ_CONFIG_INPUT);
    sstInspector.zShader    = orxConfig_GetString(orxINSPECTOR_KZ_CONFIG_SHADER);
  
    // Register clock callback to render inspector windows on each frame
    orxClock_Register(orxClock_Get(orxCLOCK_KZ_CORE), orxInspector_Update, orxNULL, orxMODULE_ID_MAIN, orxCLOCK_PRIORITY_LOWER);

    // Add event handler
    orxEvent_AddHandler(orxEVENT_TYPE_SHADER, orxInspector_EventHandler);
    orxEvent_SetHandlerIDFlags(orxInspector_EventHandler,
                               orxEVENT_TYPE_SHADER,
                               orxNULL,
                               orxEVENT_GET_FLAG(orxSHADER_EVENT_SET_PARAM),
                               orxEVENT_KU32_MASK_ID_ALL);

    // Register commands
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, RegisterObject, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, UnregisterObject, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});

    // Enable input set
    orxInput_EnableSet(sstInspector.zInputSet, orxTRUE);

    // Update status
    sstInspector.bInit = orxTRUE;

    // Pop config section
    orxConfig_PopSection();
  }
  
  // Done!
  return;
}

void orxInspector_Exit()
{
  // Was initialized?
  if(sstInspector.bInit != orxFALSE)
  {
    // Disable input set
    orxInput_EnableSet(sstInspector.zInputSet, orxFALSE);
    orxInput_ClearSet(sstInspector.zInputSet);

    // Unregister commands
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, RegisterObject);
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, UnregisterObject);

    // Remove event handler
    orxEvent_RemoveHandler(orxEVENT_TYPE_SHADER, orxInspector_EventHandler);

    // Unregister clock callback
    orxClock_Unregister(orxClock_Get(orxCLOCK_KZ_CORE), orxInspector_Update);

    // Clean runtime config section
    orxConfig_ClearSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    
    // Update status
    sstInspector.bInit = orxFALSE;
  }
  
  // Done!
  return;
}

orxSTATUS orxInspector_RegisterObject(const orxOBJECT *_pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    orxConfig_SetBool(acGUID, orxTRUE);
    orxConfig_PopSection();

    // Update status    
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!  
  return eResult;
}

orxSTATUS orxInspector_UnregisterObject(const orxOBJECT *_pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    orxConfig_ClearValue(acGUID);
    orxConfig_PopSection();

    // Update result    
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!  
  return eResult;
}

#endif // orxINSPECTOR_IMPL

#endif // _orxINSPECTOR_H_
