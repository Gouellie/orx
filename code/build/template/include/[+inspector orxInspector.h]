//! Includes

#ifndef _orxINSPECTOR_H_
#define _orxINSPECTOR_H_

#include "orxImGui.h"


//! Prototypes

void                                        orxInspector_Init();
void                                        orxInspector_Exit();
orxSTATUS                                   orxInspector_RegisterObject(const orxOBJECT *_pstObject);
orxSTATUS                                   orxInspector_UnregisterObject(const orxOBJECT *_pstObject);
orxBOOL                                     orxInspector_IsObjectRegistered(const orxOBJECT *_pstObject);


//! Defines

#define orxINSPECTOR_KZ_CONFIG_SECTION      "Inspector"
#define orxINSPECTOR_KZ_CONFIG_RUNTIME      "InspectorRuntime"

#define orxINSPECTOR_KZ_CONFIG_INPUT        "Input"
#define orxINSPECTOR_KZ_CONFIG_SHADER       "Shader"
#define orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS "InspectorFields"

#define orxINSPECTOR_KZ_INPUT_INSPECT       "Inspect"
#define orxINSPECTOR_KZ_SHADER_HIGHLIGHT    "highlight"

#define orxINSPECTOR_KU32_TABLE_FLAGS       (ImGuiTableFlags_Borders | ImGuiTableFlags_RowBg | ImGuiTableFlags_Resizable)


//! Variables / Structures

typedef struct __orxINSPECTOR_t
{
  const orxSTRING zInputSet;
  const orxSTRING zShader;
  orxBOOL         bInit;

} orxINSPECTOR;

static orxINSPECTOR sstInspector;


//! Helpers

void orxInspector_PrintGUID(const orxOBJECT *_pstObject, orxCHAR *_acBuffer, orxU32 _u32Size)
{
  orxString_NPrint(_acBuffer, _u32Size, "0x%016llX", orxStructure_GetGUID(orxSTRUCTURE(_pstObject)));
}

orxVECTOR *orxInspector_GetHighlightColor(const orxOBJECT *_pstObject, orxVECTOR *_pvColor)
{
  orxCOLOR  stColor;
  orxU64    u64GUID;

  // Pick a color based on the object's GUID
  u64GUID = orxStructure_GetGUID(_pstObject);
  orxVector_Set(&(stColor.vHSL), (orxMath_Sin((orxFLOAT)(u64GUID & 0xFFFFFFFF)) + 1.0f) / 2.0f, orxFLOAT_1, orx2F(0.7f));
  stColor.fAlpha = orxFLOAT_1;
  orxColor_FromHSLToRGB(&stColor, &stColor);

  // Done!
  return orxVector_Copy(_pvColor, &(stColor.vRGB));
}


//! Code

#ifdef orxINSPECTOR_IMPL

//! TODO: COMPLIANCE
#include <array>
#include <vector>

//! TODO: COMPLIANCE
using buf_t = std::array<orxCHAR, 1024>;
buf_t GetCStringCopy(const orxSTRING src)
{
  buf_t buffer{};
  auto copyLength = orxMIN(orxString_GetLength(src), buffer.size());
  std::copy_n(src, copyLength, buffer.begin());
  return buffer;
}

//! TODO: COMPLIANCE
buf_t GetConfigStringCopy(const orxSTRING key)
{
  return GetCStringCopy(orxConfig_GetString(key));
}

//! TODO: COMPLIANCE
buf_t GetConfigStringCopy(const orxSTRING key, orxS32 index)
{
  return GetCStringCopy(orxConfig_GetListString(key, index));
}


//! TODO: COMPLIANCE
void ConfigValueTableRow(const orxSTRING key, bool editable, const orxSTRING section = orxSTRING_EMPTY)
{
  ImGui::TableNextRow();

  // Draw the section column
  if(section != orxSTRING_EMPTY)
  {
    ImGui::TableNextColumn();
    ImGui::Text("%s", section);
  }

  // Draw the key column
  ImGui::TableNextColumn();
  ImGui::Text("%s", key);

  // Draw the value column
  ImGui::TableNextColumn();
  if(editable)
  {
    ImGui::PushID(key);
    if(orxConfig_IsList(key))
    {
      const size_t elements = orxConfig_GetListCount(key);
      std::vector<buf_t> buffers{};
      bool listElementChanged = false;
      for(auto i = 0; i < elements; i++)
      {
        // Push a unique ID for each input
        ImGui::PushID(i);

        // Initialize buffer with the current content
        auto buffer = GetConfigStringCopy(key, i);

        // Input text widget
        ImGui::InputText("", buffer.data(), buffer.size());

        // Track if the widget has received edits and lost focus
        auto changed = ImGui::IsItemDeactivated();

        // Input and button on the same line
        ImGui::SameLine();

        // Button to remove this list entry
        auto removed = ImGui::Button("Remove");

        // If we're not removing this entry, add it to the buffers defining this list
        if(!removed)
        {
          buffers.push_back(buffer);
        }

        // Track if anything in the list has changed
        listElementChanged = listElementChanged || changed || removed;
        ImGui::PopID();
      }

      // Widget to add an element to the list
      auto addedElement = ImGui::Button("Add list element");
      if(addedElement)
      {
        // If we're adding an element then we're changing the list
        listElementChanged = true;

        // Add an empty string as a placeholder for the new element
        buffers.push_back({'\0'});
      }

      if(listElementChanged)
      {
        // If any elements in the list have changed, update the list in config
        std::vector<const orxSTRING> valuePtrs{};
        for(auto i = 0; i < buffers.size(); i++)
        {
          valuePtrs.push_back(buffers[i].data());
        }
        const orxCHAR **pp = valuePtrs.data();
        orxConfig_SetListString(key, pp, (orxU32)valuePtrs.size());
      }
    }
    else
    {
      auto buf = GetConfigStringCopy(key);
      if(ImGui::InputText("", buf.data(), buf.size()))
      {
        orxConfig_SetString(key, buf.data());
      }
    }
    ImGui::PopID();
  }
  else
  {
    if(orxConfig_IsList(key))
    {
      // Show all values from the list
      if(ImGui::BeginCombo("", orxConfig_GetListString(key, 0)))
      {
        for(int i = 1; i < orxConfig_GetListCount(key); i++)
        {
          ImGui::Text("%s", orxConfig_GetListString(key, i));
        }
        ImGui::EndCombo();
      }
    }
    else
    {
      // Show text representation of a single value
      ImGui::Text("%s", orxConfig_GetString(key));
    }
  }
}

void orxInspector_InspectObjectGUID(const orxOBJECT *_pstObject)
{
  orxCHAR acGUID[20];
  
  // Get object guid
  orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
  ImGui::TextUnformatted(acGUID);
  ImGui::SameLine();

  // Make the guid easy to copy to the clipboard for use in commands
  if(ImGui::Button("Copy"))
  {
    ImGui::SetClipboardText(acGUID);
  }
  
  // Done!
  return;
}

void orxInspector_InspectObjectHeader()
{
  // Table header initialization
  ImGui::TableSetupColumn("Name");
  ImGui::TableSetupColumn("GUID");
  ImGui::TableSetupColumn("Inspector");
  ImGui::TableHeadersRow();
  
  // Done!
  return;
}

void orxInspector_InspectObjectButton(const orxOBJECT *_pstObject)
{
  ImGui::TableNextColumn();
  ImGui::TextUnformatted(orxObject_GetName(_pstObject));
  ImGui::TableNextColumn();
  orxInspector_InspectObjectGUID(_pstObject);
  ImGui::TableNextColumn();
  if(ImGui::Button("Inspect"))
  {
    orxInspector_RegisterObject(_pstObject);
  }
}

void orxInspector_InspectParent(const orxOBJECT *_pstObject)
{
  if(ImGui::CollapsingHeader("Parent"))
  {
    orxOBJECT *pstParent = orxOBJECT(orxObject_GetParent(_pstObject));
    if(pstParent != orxNULL)
    {
      ImGui::PushID(pstParent);
      
      if(ImGui::BeginTable("Parent", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        orxInspector_InspectObjectHeader();
        orxInspector_InspectObjectButton(pstParent);
      }
      ImGui::EndTable();
      
      ImGui::PopID();
    }
  }
  
  // Done!
  return;
}

void orxInspector_InspectSiblings(const orxOBJECT *_pstObject)
{
  if(ImGui::CollapsingHeader("Siblings"))
  {
    orxOBJECT *pstParent = orxOBJECT(orxObject_GetParent(_pstObject));
    if(pstParent != orxNULL)
    {
      orxOBJECT *pstFirstSibling = orxObject_GetChild(pstParent);
      if(pstFirstSibling != orxNULL)
      {
        if(ImGui::BeginTable("Siblings", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
        {
          orxInspector_InspectObjectHeader();
          for(orxOBJECT *pstSibling = pstFirstSibling;
              pstSibling != orxNULL;
              pstSibling = orxObject_GetSibling(pstSibling))
          {
            if(pstSibling != _pstObject)
            {
              ImGui::PushID(pstSibling);
              orxInspector_InspectObjectButton(pstSibling);
              ImGui::PopID();
            }
          }
        }
        ImGui::EndTable();
      }
    }
  }
  
  // Done!
  return;
}

void orxInspector_InspectChildren(const orxOBJECT *_pstObject)
{
  if(ImGui::CollapsingHeader("Children"))
  {
    orxOBJECT *pstChild = orxObject_GetChild(_pstObject);
    if(pstChild != orxNULL)
    {
      if(ImGui::BeginTable("Children", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        orxInspector_InspectObjectHeader();
        for(; pstChild != orxNULL; pstChild = orxObject_GetSibling(pstChild))
        {
          ImGui::PushID(pstChild);
          orxInspector_InspectObjectButton(pstChild);
          ImGui::PopID();
        }
      }
      ImGui::EndTable();
    }
  }
  
  // Done!
  return;
}

//! TODO: COMPLIANCE
void Status(const orxOBJECT *_pstObject)
{
  // Do nothing if the object is invalid/null
  if(!_pstObject)
  {
    return;
  }

  if(ImGui::CollapsingHeader("Status"))
  {
    if(ImGui::BeginTable("Status", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      // GUID
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("GUID");
      ImGui::TableNextColumn();
      orxInspector_InspectObjectGUID(_pstObject);

      // Life time
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Life time");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f", orxObject_GetLifeTime(_pstObject));

      // Active time
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Active time");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f", orxObject_GetActiveTime(_pstObject));

      // Group
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Group");
      ImGui::TableNextColumn();
      ImGui::Text("%s", orxString_GetFromID(orxObject_GetGroupID(_pstObject)));

      // Current animation
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Animation");
      ImGui::TableNextColumn();
      ImGui::TextUnformatted(orxObject_GetCurrentAnim(_pstObject));

      // World position
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Position");
      ImGui::TableNextColumn();
      orxVECTOR position;
      orxObject_GetWorldPosition(_pstObject, &position);
      ImGui::Text("(%0.1f, %0.1f, %0.1f)", position.fX, position.fY, position.fZ);

      // Velocity
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Speed");
      ImGui::TableNextColumn();
      orxVECTOR speed;
      orxObject_GetSpeed(_pstObject, &speed);
      ImGui::Text("(%0.1f, %0.1f)", speed.fX, speed.fY);

      // Rotation
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Rotation");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f degrees", orxObject_GetRotation(_pstObject) * orxMATH_KF_RAD_TO_DEG);

      // Angular velocity
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Angular velocity");
      ImGui::TableNextColumn();
      ImGui::Text("%0.1f degrees/second", orxObject_GetAngularVelocity(_pstObject) * orxMATH_KF_RAD_TO_DEG);

      // Scale
      ImGui::TableNextColumn();
      ImGui::TextUnformatted("Scale");
      ImGui::TableNextColumn();
      orxVECTOR scale;
      orxObject_GetScale(_pstObject, &scale);
      ImGui::Text("(%0.1f, %0.1f)", scale.fX, scale.fY);
    }
    ImGui::EndTable();
  }
}

//! TODO: COMPLIANCE
void Config(const orxSTRING section, bool editable)
{
  if(ImGui::CollapsingHeader("Config"))
  {
    const auto initialIndent = 5.0f;
    ImGui::Indent(initialIndent);

    auto ConfigRows = [editable]()
    {
      auto keys = orxConfig_GetKeyCount();
      for(orxU32 i = 0; i < keys; i++)
      {
        auto key = orxConfig_GetKey(i);
        ConfigValueTableRow(key, editable);
      }
    };

    // Track additional indentation levels from parent config sections
    auto indentOffset = 2.0f;

    // Object config section and its inheritance hierarchy
    if(ImGui::CollapsingHeader(section))
    {
      // Push the selected config section to make it active
      orxConfig_PushSection(section);

      // Create a table with one row per key/value pair in the section
      if(ImGui::BeginTable(section, 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        // Section config
        ImGui::PushID(section);
        ConfigRows();
        ImGui::PopID();

        ImGui::EndTable();
      }

      orxConfig_PopSection();

      auto parent = orxConfig_GetParent(section);
      auto tableFlags = ImGuiTreeNodeFlags_DefaultOpen;
      while(parent != orxNULL && parent != orxSTRING_EMPTY && ImGui::CollapsingHeader(parent, tableFlags) && ImGui::BeginTable(parent, 2, orxINSPECTOR_KU32_TABLE_FLAGS))
      {
        ImGui::Indent(5.0f);
        indentOffset += 5.0f;
        // Show the config from the parent section too
        ImGui::PushID(parent);
        orxConfig_PushSection(parent);
        ConfigRows();
        orxConfig_PopSection();
        ImGui::PopID();
        parent = orxConfig_GetParent(parent);

        ImGui::EndTable();
      }
    }

    // Reset indentation from config sections if any was added
    if(indentOffset > 0.0f)
    {
      ImGui::Indent(-indentOffset);
    }

    // Other custom config values to show
    orxConfig_PushSection(section);
    if(orxConfig_HasValueNoCheck(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS) &&
        ImGui::CollapsingHeader("Custom fields") &&
        ImGui::BeginTable("Custom fields", 3, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      ImGui::PushID("Custom");

      ImGui::TableSetupColumn("Section");
      ImGui::TableSetupColumn("Key");
      ImGui::TableSetupColumn("Value");
      ImGui::TableHeadersRow();

      for(orxU32 u32Element = 0, u32ElementCount = orxConfig_GetListCount(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS);
          u32Element < u32ElementCount;
          u32Element++)
      {
        const orxSTRING zPath = orxConfig_GetListString(orxINSPECTOR_KZ_CONFIG_DEBUG_FIELDS, u32Element);
        if(*zPath != orxCHAR_NULL)
        {
          orxS32 s32SeparatorIndex = orxString_SearchCharIndex(zPath, '.', 0);
          if(s32SeparatorIndex > 0)
          {
            orxCHAR acSection[1024];

            ImGui::PushID(u32Element);

            orxString_NPrint(acSection, sizeof(acSection), "%.*s", s32SeparatorIndex, zPath);
            orxConfig_PushSection(acSection);
            ConfigValueTableRow(zPath + s32SeparatorIndex + 1, editable, acSection);
            orxConfig_PopSection();

            ImGui::PopID();
          }
        }
      }
      ImGui::PopID();

      ImGui::EndTable();
    }
    orxConfig_PopSection();

    ImGui::Indent(-initialIndent);
  }
}

//! TODO: COMPLIANCE
struct ObjectShaderSpec
{
  int shaderCount{0};             // Number of shaders applied to an object
  bool hasHighlightShader{false}; // True if the inspector highlight shader is applied, otherwise false
};

//! TODO: COMPLIANCE
ObjectShaderSpec GetObjectShaderSpec(const orxOBJECT *_pstObject)
{
  ObjectShaderSpec spec{};

  // Get a reference to the highlighting shader
  auto shader = orxShader_CreateFromConfig(sstInspector.zShader);
  orxASSERT(shader != orxNULL);
  // Get the shader's ID
  auto highlightShaderID = orxShader_GetID(shader);
  // Clean up our shader reference
  orxShader_Delete(shader);

  auto shaderPointer = orxOBJECT_GET_STRUCTURE(_pstObject, SHADERPOINTER);
  if(shaderPointer != orxNULL)
  {
    for(int i = 0; i < orxSHADERPOINTER_KU32_SHADER_NUMBER; i++)
    {
      auto objectShader = orxShaderPointer_GetShader(shaderPointer, i);
      if(objectShader != orxNULL)
      {
        spec.shaderCount++;
        auto objectShaderID = orxShader_GetID(objectShader);
        if(objectShaderID == highlightShaderID)
        {
          spec.hasHighlightShader = true;
        }
      }
    }
  }

  return spec;
}

//! TODO: COMPLIANCE
void HighlightShaderCheckbox(orxOBJECT *_pstObject)
{
  if(orxObject_GetWorkingGraphic(_pstObject) != orxNULL)
  {
    auto shaderSpec = GetObjectShaderSpec(_pstObject);

    orxVECTOR highlightColor;
    orxInspector_GetHighlightColor(_pstObject, &highlightColor);
    ImVec4 highlightColorIm = {highlightColor.fR, highlightColor.fG, highlightColor.fB, 1.0};
    ImGui::TextColored(highlightColorIm, "Highlight with shader");
    ImGui::SameLine();

    // The highlight is active if we have a non-NULL pointer to the highlight shader
    bool highlight = shaderSpec.hasHighlightShader;
    if(ImGui::Checkbox("##highlight", &highlight))
    {
      if(highlight && !shaderSpec.hasHighlightShader)
      {
        // No existing shaders, so we can add the highlight directly to the object
        orxObject_AddShader(_pstObject, sstInspector.zShader);
      }
      else if(!highlight && shaderSpec.hasHighlightShader)
      {
        // We have the shader set, so remove it
        orxObject_RemoveShader(_pstObject, sstInspector.zShader);
      }
    }
  }
}

//! TODO: COMPLIANCE
void Shaders(const orxOBJECT *_pstObject)
{
  auto shaderSpec = GetObjectShaderSpec(_pstObject);

  if(shaderSpec.shaderCount > 0 && ImGui::CollapsingHeader("Shaders"))
  {
    if(ImGui::BeginTable("Shaders", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      auto shaderPointer = orxOBJECT_GET_STRUCTURE(_pstObject, SHADERPOINTER);
      orxASSERT(shaderPointer != orxNULL);
      for(int i = 0; i < orxSHADERPOINTER_KU32_SHADER_NUMBER; i++)
      {
        auto shader = orxShaderPointer_GetShader(shaderPointer, i);
        if(shader != orxNULL)
        {
          ImGui::TableNextColumn();
          ImGui::TextUnformatted("Name");
          ImGui::TableNextColumn();
          ImGui::TextUnformatted(orxShader_GetName(shader));
        }
      }
    }
    ImGui::EndTable();
  }
}

//! TODO: COMPLIANCE
void Graphic(const orxOBJECT *_pstObject)
{
  auto graphic = orxObject_GetWorkingGraphic(_pstObject);
  auto texture = orxObject_GetWorkingTexture(_pstObject);
  auto text = orxObject_GetTextString(_pstObject);
  if((graphic != orxNULL && texture != orxNULL || text != orxSTRING_EMPTY) && ImGui::CollapsingHeader("Graphic"))
  {
    // Setup table columns
    if(ImGui::BeginTable("Graphic", 2, orxINSPECTOR_KU32_TABLE_FLAGS))
    {
      if(text != orxSTRING_EMPTY)
      {
        // Show object text

        // Identify type of graphic
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Text");
        // Show graphic content
        ImGui::TableNextColumn();
        ImGui::TextUnformatted(text);
      }
      else
      {
        // Show object graphic

        // Scale of graphic
        orxVECTOR scale;
        orxObject_GetScale(_pstObject, &scale);

        // Show information on scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Scale");
        ImGui::TableNextColumn();
        ImGui::Text("(%0.1f, %0.1f)", scale.fX, scale.fY);

        // Flip state of the graphic
        orxBOOL flipX, flipY;
        orxObject_GetFlip(_pstObject, &flipX, &flipY);

        // Show information on scale
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Flip");
        ImGui::TableNextColumn();
        ImGui::Text("(%s, %s)", (flipX ? "Flip X" : "Normal X"), (flipY ? "Flip Y" : "Normal Y"));

        // Identify type of graphic
        ImGui::TableNextColumn();
        ImGui::TextUnformatted("Texture");

        // Show graphic content
        ImGui::TableNextColumn();
        // Get overall texture dimensions
        orxFLOAT textureWidth, textureHeight;
        orxTexture_GetSize(texture, &textureWidth, &textureHeight);

        // Get the origin and size of the active graphic
        orxVECTOR origin, size;
        orxGraphic_GetOrigin(graphic, &origin);
        orxGraphic_GetSize(graphic, &size);

        // Find the location of the graphic within the overall texture in normalized coordinates
        ImVec2 uv0, uv1;
        // Top left of the texture region
        uv0.x = origin.fX / textureWidth;
        uv0.y = origin.fY / textureHeight;
        // Lower right of the texture region
        uv1.x = (origin.fX + size.fX) / textureWidth;
        uv1.y = (origin.fY + size.fY) / textureHeight;

        // Flip uv coordinates if the object is flipped
        ImVec2 uv0Temp{uv0};
        if(flipX)
        {
          uv0.x = uv1.x;
          uv1.x = uv0Temp.x;
        }
        if(flipY)
        {
          uv0.y = uv1.y;
          uv1.y = uv0Temp.y;
        }

        // Get the texture and display the portion that matches the object's graphic
        auto textureID = (ImTextureID)orxTexture_GetBitmap(texture);
        ImGui::Image(textureID, {size.fX * scale.fX, size.fY * scale.fY}, uv0, uv1);
      }
    }
    ImGui::EndTable();
  }
}

void orxInspector_InspectObject(orxOBJECT *_pstObject)
{
  bool bRegistered = true;
  const orxSTRING zName = orxObject_GetName(_pstObject);

  ImGui::PushID(_pstObject);
  if(ImGui::Begin(zName, &bRegistered))
  {
    HighlightShaderCheckbox(_pstObject);
    Status(_pstObject);
    Config(zName, true);
    Graphic(_pstObject);
    Shaders(_pstObject);
    orxInspector_InspectParent(_pstObject);
    orxInspector_InspectSiblings(_pstObject);
    orxInspector_InspectChildren(_pstObject);
  }
  ImGui::End();
  ImGui::PopID();

  if(bRegistered == false)
  {
    orxInspector_UnregisterObject(_pstObject);
    orxObject_RemoveShader(_pstObject, sstInspector.zShader);
  }

  // Done!
  return;
}

void orxInspector_CommandRegisterObject(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->u64Value = orxU64_UNDEFINED;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if(pstObject != orxNULL)
  {
    // Register the object
    if(orxInspector_RegisterObject(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }

  // Done!
  return;
}

void orxInspector_CommandUnregisterObject(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->u64Value = orxU64_UNDEFINED;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Valid?
  if(pstObject != orxNULL)
  {
    // Unregister the object
    if(orxInspector_UnregisterObject(pstObject) != orxSTATUS_FAILURE)
    {
      // Update result
      _pstResult->u64Value = _astArgList[0].u64Value;
    }
  }

  // Done!
  return;
}

void orxInspector_CommandIsObjectRegistered(orxU32 _u32ArgNumber, const orxCOMMAND_VAR *_astArgList, orxCOMMAND_VAR *_pstResult)
{
  orxOBJECT *pstObject;

  // Update result
  _pstResult->bValue = orxFALSE;

  // Gets object
  pstObject = orxOBJECT(orxStructure_Get(_astArgList[0].u64Value));

  // Update result
  _pstResult->bValue = orxInspector_IsObjectRegistered(pstObject);

  // Done!
  return;
}

orxSTATUS orxInspector_EventHandler(const orxEVENT *_pstEvent)
{
  orxSTATUS eResult = orxSTATUS_SUCCESS;

  // Get the event payload
  orxSHADER_EVENT_PAYLOAD *pstPayload = (orxSHADER_EVENT_PAYLOAD *)_pstEvent->pstPayload;

  // Inspector highlight?
  if((orxString_Compare(pstPayload->zShaderName, sstInspector.zShader) == 0)
  && (orxString_Compare(pstPayload->zParamName, orxINSPECTOR_KZ_SHADER_HIGHLIGHT) == 0))
  {
    // Set the highlight color for the shader
    orxInspector_GetHighlightColor(orxOBJECT(_pstEvent->hSender), &(pstPayload->vValue));
  }

  // Done!
  return eResult;
}

void orxInspector_Update(const orxCLOCK_INFO *_pstClockInfo, void *_pContext)
{
  // Push input set
  orxInput_PushSet(sstInspector.zInputSet);

  // Should inspect object?
  if(orxInput_HasBeenActivated(orxINSPECTOR_KZ_INPUT_INSPECT))
  {
    orxVECTOR vMousePosition;

    // Pick object
    orxRender_GetWorldPosition(orxMouse_GetPosition(&vMousePosition), orxNULL, &vMousePosition);
    orxOBJECT *pstObject = orxObject_Pick(&vMousePosition, orxSTRINGID_UNDEFINED);

    // Found?
    if(pstObject != orxNULL)
    {
      // Toggle its registration
      if(orxInspector_IsObjectRegistered(pstObject))
      {
        orxInspector_UnregisterObject(pstObject);
      }
      else
      {
        orxInspector_RegisterObject(pstObject);
      }
    }
  }

  // Pop input set
  orxInput_PopSet();

  // Inspect all registered objects
  orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
  for(orxU32 u32KeyIndex = 0, u32KeyCount = orxConfig_GetKeyCount(); u32KeyIndex < u32KeyCount; u32KeyIndex++)
  {
    const orxSTRING zKey  = orxConfig_GetKey(u32KeyIndex);
    orxU64 u64GUID        = orxU64_UNDEFINED;
    if(orxString_ToU64(zKey, &u64GUID, orxNULL) != orxSTATUS_FAILURE)
    {
      orxOBJECT *pstObject = orxOBJECT(orxStructure_Get(u64GUID));
      if(pstObject != orxNULL)
      {
        orxInspector_InspectObject(pstObject);
      }
      else
      {
        orxConfig_ClearValue(zKey);
      }
    }
  }
  orxConfig_PopSection();

  // Done!
  return;
}

void orxInspector_Init()
{
  // Not already initialized?
  if(sstInspector.bInit == orxFALSE)
  {
    // Push config section
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_SECTION);

    // Inits variables
    orxMemory_Zero(&(sstInspector), sizeof(orxINSPECTOR));
    sstInspector.zInputSet  = orxConfig_GetString(orxINSPECTOR_KZ_CONFIG_INPUT);
    sstInspector.zShader    = orxConfig_GetString(orxINSPECTOR_KZ_CONFIG_SHADER);

    // Register clock callback to render inspector windows on each frame
    orxClock_Register(orxClock_Get(orxCLOCK_KZ_CORE), orxInspector_Update, orxNULL, orxMODULE_ID_MAIN, orxCLOCK_PRIORITY_LOWER);

    // Add event handler
    orxEvent_AddHandler(orxEVENT_TYPE_SHADER, orxInspector_EventHandler);
    orxEvent_SetHandlerIDFlags(orxInspector_EventHandler,
                               orxEVENT_TYPE_SHADER,
                               orxNULL,
                               orxEVENT_GET_FLAG(orxSHADER_EVENT_SET_PARAM),
                               orxEVENT_KU32_MASK_ID_ALL);

    // Register commands
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, RegisterObject, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, UnregisterObject, "GUID", orxCOMMAND_VAR_TYPE_U64, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});
    orxCOMMAND_REGISTER_CORE_COMMAND(Inspector, IsObjectRegistered, "Registered?", orxCOMMAND_VAR_TYPE_BOOL, 1, 0, {"Object", orxCOMMAND_VAR_TYPE_U64});

    // Enable input set
    orxInput_EnableSet(sstInspector.zInputSet, orxTRUE);

    // Update status
    sstInspector.bInit = orxTRUE;

    // Pop config section
    orxConfig_PopSection();
  }

  // Done!
  return;
}

void orxInspector_Exit()
{
  // Was initialized?
  if(sstInspector.bInit != orxFALSE)
  {
    // Disable input set
    orxInput_EnableSet(sstInspector.zInputSet, orxFALSE);
    orxInput_ClearSet(sstInspector.zInputSet);

    // Unregister commands
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, RegisterObject);
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, UnregisterObject);
    orxCOMMAND_UNREGISTER_CORE_COMMAND(Inspector, IsObjectRegistered);

    // Remove event handler
    orxEvent_RemoveHandler(orxEVENT_TYPE_SHADER, orxInspector_EventHandler);

    // Unregister clock callback
    orxClock_Unregister(orxClock_Get(orxCLOCK_KZ_CORE), orxInspector_Update);

    // Clean runtime config section
    orxConfig_ClearSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);

    // Update status
    sstInspector.bInit = orxFALSE;
  }

  // Done!
  return;
}

orxSTATUS orxInspector_RegisterObject(const orxOBJECT *_pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    orxConfig_SetBool(acGUID, orxTRUE);
    orxConfig_PopSection();

    // Update status
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!
  return eResult;
}

orxSTATUS orxInspector_UnregisterObject(const orxOBJECT *_pstObject)
{
  orxSTATUS eResult = orxSTATUS_FAILURE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    orxConfig_ClearValue(acGUID);
    orxConfig_PopSection();

    // Update result
    eResult = orxSTATUS_SUCCESS;
  }

  // Done!
  return eResult;
}

orxBOOL orxInspector_IsObjectRegistered(const orxOBJECT *_pstObject)
{
  orxBOOL bResult = orxFALSE;

  // Valid?
  if(_pstObject != orxNULL)
  {
    orxCHAR acGUID[32];
    orxInspector_PrintGUID(_pstObject, acGUID, sizeof(acGUID));
    orxConfig_PushSection(orxINSPECTOR_KZ_CONFIG_RUNTIME);
    bResult = orxConfig_GetBool(acGUID);
    orxConfig_PopSection();
  }

  // Done!
  return bResult;
}

#endif // orxINSPECTOR_IMPL

#endif // _orxINSPECTOR_H_
